{  PT scanner-parser pass  Ver. 1.08
    
  Abstract:
	  The scanner parser pass of the PT compiler consists of two
	modules, a scanner-screener and a parser, which interact as
	coroutines.

	  Both modules are table driven by separately specified S/SL
	programs.  The routines of this program implement the primitive
	operations and semantic operations invoked by those S/SL programs.

	  Input Files:

		stdIdentifiers - PT keywords and predeclared identifiers

		scanSsl, parseSsl - tables to drive the scanner and parser

		source - user program text

		options - compiler toggle settings. Recognized options are:

			t1 - trace scanner execution
			t2 - trace parser execution
			l - suppress generation of run-time
			    source coordinate information
			DD - (D is a decimal digit) the first DD characters
			     of identifiers in the user program are 
			     significant (DD >= 09 and DD <= 31).

	 Output Files:

		parseStream - parsed token stream (in postfix) for
		  input to the semantic analysis pass.

		output - diagnostic messages

									}

program ScannerParser(output, stdIdentifiers, scanSsl, parseSsl, source,
			parseStream, options);

    const

{ ===== Character classes (scanner input tokens), copied here from scan.def }

(********** CHANGED *)
	{ Input Tokens }
        lLetter = 0;
        firstCharClass = 0;
        lDigit = 1;
        lPlus = 2;
        lMinus = 3;
        lStar = 4;
        lColon = 5;
        lEquals = 6;
        lDot = 7;
        lComma = 8;
        lSemicolon = 9;
        lSlash = 10;
        lHash = 11;
        lExclamation = 12;
	lAtSign = 13;
	lQuote = 14;
	lLeftAngle = 15;
	lRightAngle = 16;
	lLeftParen = 17;
	lRightParen = 18;
	lLeftBracket = 19;
	lRightBracket = 20;
	lLeftBrace = 21;
	lRightBrace = 22;
	lBlank = 23;
	lIllegal = 24;
	lNewLine = 25;
	lTab = 26;
	lNewPage = 27;
	lEndFile = 28;
	lastCharClass = 28;
(**********)

{ ===== }


	{ Scanner -> Parser token stream definitions }
	firstSyntaxToken  =  -1;

	{ Nonexistent input token used only in syntax error recovery }
	pSyntaxError = -1;

{ ===== Scanner -> Parser token stream defintiions (scanner output tokens),
	copied here from scan.def or parser.def, which must agree!}

(********** CHANGED *)
	{ Output Tokens }
	pDiv = 0;
	firstKeywordToken = 0;
	pMod = 1;
	pOr = 2;
	pAnd = 3;
	pNot = 4;
	pElse = 5;
	pOf = 6;
	pArray = 7;
	pFile = 8;
	pPacked = 9;
	pProgram = 10;
	pLet = 11;
	pVar = 12;
	pType = 13;
	pFunction = 14;
	pIf = 15;
	pCase = 16;
	pSwitch = 17;
	pDefault = 18;
	pElsif = 19;
	pLoop = 20;
	pBreak = 21;
	pWhen = 22;
	pClass = 23;
	pPublic = 24;
	pReturn = 25;
	lastKeywordToken = 25;
	pIdentifier = 26;
	firstCompoundInputToken = 26;
	pInteger = 27;
	pLiteral = 28;
	lastCompoundInputToken = 28;
	pNewLine = 29;
	pEndFile = 30;
	pPlus = 31;
	pMinus = 32;
	pStar = 33;
	pDot = 34;
	pComma = 35;
	pSemicolon = 36;
	pHash = 37;
	pAtSign = 38;
	pEqualsEquals = 39;
	pColon = 40;
	pEquals = 41;
	pNotEqual = 42;
	pLess = 43;
	pLessEqual = 44;
	pGreaterEqual = 45;
	pGreater = 46;
	pLeftParen = 47;
	pRightParen = 48;
	pLeftBracket = 49;
	pRightBracket = 50;
	pLeftBrace = 51;
	pRightBrace = 52;
	pDotDot = 53;
	lastSyntaxToken = 53;
(**********)

{ ===== }


	{ Parser -> Semantic pass token stream definitions }

{ ===== Semantic tokens, copied here from parser.def or semantic.def, which must agree!  }

(********** CHANGED *)
	{ Output Tokens }
        sIdentifier = 0;
        firstSemanticToken = 0;
        firstCompoundSemanticToken = 0;
        sInteger = 1;
        sLiteral = 2;
        lastCompoundSemanticToken = 2;
        sParmBegin = 3;
        sParmEnd = 4;
        sConst = 5;
        sType = 6;
        sVar = 7;
        sProcedure = 8;
        sPublic = 9;
        sBegin = 10;
        sEnd = 11;
        sNegate = 12;
        sArray = 13;
        sPacked = 14;
        sFile = 15;
        sRange = 16;
        sCaseStmt = 17;
        sDefault = 18;
        sCaseEnd = 19;
        sLabelEnd = 20;
        sExpnEnd = 21;
        sNullStmt = 22;
        sAssignmentStmt = 23;
        sSubscript = 24;
        sCallStmt = 25;
        sFieldWidth = 26;
        sIfStmt = 27;
        sThen = 28;
        sElse = 29;
        sWhileStmt = 30;
        sExtern = 31;
        sModule = 32;
        sLoopStmt = 33;
        sLoopBreakIf = 34;
        sLoopEnd = 35;
        sReturn = 36;
        sEq = 37;
        sNE = 38;
        sLT = 39;
        sLE = 40;
        sGT = 41;
        sGE = 42;
        sAdd = 43;
        sSubtract = 44;
        sMultiply = 45;
        sDivide = 46;
        sModulus = 47;
        sInfixOr = 48;
        sOr = 49;
        sInfixAnd = 50;
        sAnd = 51;
        sNot = 52;
        sSubstring = 53;
        sLength = 54;
        sNewLine = 55;
        lastSemanticToken = 55;
(**********)

{ ===== }


	{ S/SL Operations }
	firstTableOperation = 0;
	{ Primitive S/SL operations }
	oCall = 0;
	oReturn = 1;
	oRuleEnd = 2;
	oJumpBack = 3;
	oJumpForward = 4;
	oInput = 5;
	oInputAny = 6;
	oInputChoice = 7;
	oEmit = 8;
	oError = 9;
	oChoice	= 10;
	oChoiceEnd = 11;
	oSetParameter = 12;
	oSetResult = 13;

	{ Scanner Semantic Mechanism Operations }
	oBufferSave = 14;
	lastScanTableOperation = 14;

	{ Parser Semantic Mechanism Operations }
	{ none }
	lastParseTableOperation = 13;


	{ Error codes }
	firstErrorCode = 0;
	eTextBufferOverflow = 0;
	eIdentTextOverflow = 1;
	eIdentTableOverflow = 2;
	eParseCallStackOvfl = 3;
	ePrematureEOF = 4;
	lastAbortCode = 4;

	{ Scanner error codes, copied here from scan.def }
	firstScanError = 5;
	eIllegalChar = 5;
	eLiteralLine = 6;
	eLiteralEOF = 7;
	eCommentEOF = 8;
	eNoSeparator = 9;
	lastScanError = 9;

	{ Screener error codes - values must be bigger than scanner error codes }
	eNullString = 10;
	eIntegerOverflow = 11;
	eIdentifierTooLong = 12;
	eSyntaxError = 13;
	eOptionsError = 14;
	eExtraneousSource = 15;
	lastErrorCode = 15;

	{ S/SL failure codes }
	firstFailureCode = 0;
	fSemanticChoiceFailed = 0;
	fChoiceRuleFailed = 1;
	lastFailureCode = 1;

	{ Each assertion in the program is tagged with a unique identifying 
	  value - this makes it easy to find assertion failure conditions
	  by searching for 'assertNN' below when assertion NN fails.       }
	assert1 = 1;
	assert2 = 2;
	assert3 = 3;
	assert4 = 4;
	assert5 = 5;
	assert6 = 6;
	assert7 = 7;
	assert8 = 8;
	assert9 = 9;
	assert10 = 10;
	assert11 = 11;
	assert12 = 12;
	assert13 = 13;
	assert14 = 14;
	assert15 = 15;
	assert16 = 16;
	assert17 = 17;

	{ Translator limits }
	scanTableSize = 500;	{ max }
	parseTableSize = 2000; 	{ max }

	{ The following value MUST match the total number of
	  keywords and idents entered in the stdIdentifiers file. }
(********** CHANGED *)
(*	numberStdIdentifiers = 43; *)
(********** CHANGED 858 *)
(*	numberStdIdentifiers = 44; *)
(**********)
	numberStdIdentifiers = 45;
(**********)

	textBufferSize = 80;
	identTableSize = 1601;	{ must be prime }
	identTextSize = 16000;
	charSetSize = 127;	{ actually size-1 }
	maxInteger = 32767;
	maxIntDivTen = 3276;
	maxIntModTen = 7;
	shiftLeft7 = 128;
	shiftLeft4 = 16;
	minInteger = -32767;
	maxIdentifierLength = 50;
	minSignificantChars = 8;	{ in an identifier }
	maxLineNumber = 9999;
	maxErrors = 100;
	scanCallStackSize = 5;

	{ dummy identifier-token value used in syntax error recovery }
	defaultIdentifier = -1;

	{ misc. }
	tab = '	';
	blank = ' ';
(********** CHANGED *)
(*	quote = ''''; *)
	quote = '"';
(**********)
	null = 0;

	{ Phase identification values - for use by common routines }
	scan = 0;
	parse = 1;

    type
	IdentTextReference = 0 .. identTextSize;
	CharClass = firstCharClass .. lastCharClass;
	SyntaxToken = firstSyntaxToken .. lastSyntaxToken;
	FailureCodes = firstFailureCode .. lastFailureCode;
	ErrorCodes = firstErrorCode .. lastErrorCode;
	ScanOperation = firstTableOperation .. lastScanTableOperation;
	ParseOperation = firstTableOperation .. lastParseTableOperation;
	IdentTableReference = 1 .. identTableSize;
	PhaseNames =  scan .. parse;

    var
	{ Scanner-Screener variables }

	{ scanner input stream - PT source program }
	source :  text;

	{ keywords and predeclared identifiers }
	stdIdentifiers :  text;

	{ scanner S/SL }
	scanSsl :  file of integer;

	{ S/SL table to drive the scanner }
	scanTable :  array [0 .. scanTableSize] of integer;

	{ The S/SL Rule Call Stack:
	  The Rule Call Stack implements Syntax/Semantic
	  Language rule call and return.
	  Each time an oCall operation is executed,
	  the table return address is pushed onto the
	  Rule Call Stack.  When an oReturn is executed,
	  the return address is popped from the stack.
	  An oReturn executed when the Rule Call Stack is
	  empty terminates table execution.  The scanner
	  call stack and table pointer are global so the
	  scanner can operate as a coroutine with the parser. }
	scanCallStackTop :  0 .. scanCallStackSize;
	scanCallStack :  array [1 .. scanCallStackSize] of 0 .. scanTableSize;
	scanTablePointer :  0 .. scanTableSize;

	{ Buffer which temporarily stores the text for compound
	  tokens identifier, integer and literal after their acceptance. 
	  The text of literal string tokens is passed from the scanner
	  to the parser via this variable.				}
	textBuffer :  array [1 .. textBufferSize] of char;
	tokenTextLength :  0 .. textBufferSize;

	{ Significant identifier characters; default is maxIdentifierLength }
	significantChars :  0 .. maxIdentifierLength;

	inputChar :  char;	{ last char read from source }
	lastInputChar :  char;	{ char read prior to inputChar }
	scanToken : CharClass;	{ char class corresponding to inputChar }

	{ Text table : storage for the character representation of identifiers }
	identText :  array [1 .. identTextSize] of char;
	identTextEnd :  IdentTextReference;  { last allocated text table slot }

	{ Lookup table which is used to determine a character's lexical
	  token class based on its ordinal value in the collating sequence }
	charClassMap :  array [0 .. charSetSize] of CharClass;

	{ Identifier table :  3 fields, text index, length and value }
	{ Pointer to the character representation of the ident }
	identTextIndex :  array [IdentTableReference] of IdentTextReference;
	{ Number of characters in the ident }
	identLength :  array [IdentTableReference] of char;	{ chr(length) }
	{ The value used to distinguish identifier tokens is the
	  current number of identifiers (standard and user defined)
	  that have been entered in the ident table. Keywords have
	  negative values in this field.			   }
	identTokenValue : array [IdentTableReference] of integer;
	{ Number of occupied ident table entries }
	numberOfIdents :  0 .. identTableSize;

	{ An ident table index which is computed as a function
	  of the character representation of a ident.	}
	hashValue :  IdentTableReference;


	{ Parser variables }

	{ Parser S/SL }
	parseSsl :  file of integer;

	{ S/SL table to drive the parser }
	parseTable :  array [0 .. parseTableSize] of integer;
	parseTablePointer :  0 .. parseTableSize;

	{ Operation being executed by the Parser S/SL table walker }
	parserOperation :  ParseOperation;

	{ Parser table walker termination control. Initially true;
	  set false at normal end of processing and upon encountering
	  an unrecoverable error.				    }
	parsing :  Boolean;

	{ Communication channel between the Scanner and Parser.  Compound
	  tokens have associated values :  identifier - ident table index,
	  integer - value.  The text and length of identifiers and literals
	  is passed via textBuffer and tokenTextLength.			  }
	parseInputToken :  SyntaxToken;
	parseTokenValue :  integer;

	{ Parser's private copy of compound token components.  These
	  values are accessed by the semantic operations of the parser.	}
	compoundToken :  SyntaxToken;	{ identifier, integer or literal }
	compoundTokenValue :  integer;
	compoundTokenLength :  0 .. textBufferSize;
	compoundTokenText :  array [1 .. textBufferSize] of char;

	{ Parser output token stream }
	parseStream :  file of integer;

	{ Options Control }
	options :  text;
	scantracing :  Boolean;	{ default is false }
	parsetracing :  Boolean;	{ default is false }
	{ Number of characters to be used to distinguish user-defined
	  identifiers;  the default value is maxIdentifierLength.    }
	significantIdentTextSize :  minSignificantChars .. maxIdentifierLength;

	{ Flag set when translation is being aborted }
	abort :  Boolean;	{ initially false }

	{ Variables Used in Syntax Error Recovery }
	newInputLine :  Boolean;   { initially false }
	savedInputToken :  SyntaxToken;
	{ Syntax error line number }
	lineNumber :  0 .. maxLineNumber;
	{ Scanner error lookahead line number }
	nextLineNumber :  0 .. maxLineNumber;
	{ Number of errors detected so far }
	errorCount :  integer;

	{ UNIX argument file idents }
	{NstdIdentifiers, NscanSsl, NparseSsl, 
	  Nsource, NparseStream, Noptions:
		packed array [1 .. 50 ] of char;}


    procedure Assert (assertion: Boolean; number: integer);
	{ Procedure to implement programmer assertion checking
	  with identification numbers.				}
	begin
	    if not assertion then
		begin
		    write ('### Parser Assertion ', number: 1, ' failed');
		    writeln;
		    { Cause a crash }
		    case 2 of 1: end;
		end;
	end { Assert };


    procedure SslFailure (failCode: FailureCodes);
	begin
	    write ('### S/SL program failure:  ');

	    case failCode of
		fSemanticChoiceFailed:
		    write ('Semantic choice failed');
		fChoiceRuleFailed:
		    write ('Choice rule returned without a value');
	    end;

	    writeln;
	    write ('while processing line ', lineNumber);
	    writeln;
	    Assert (false, assert1);
	end { SslFailure };


    procedure ReportSyntaxError;
	{ Print the token at which the syntax error was detected.
	  Error has already printed the label for the error message. }
	var
	    i : integer;
	begin
	    if parseInputToken > lastCompoundInputToken then
		{ The token is a Pascal special symbol }
		write (lastInputChar)
	    else
		{ Identifier, integer or literal }
		begin
		    i := 1;
		    while i <= tokenTextLength do
			begin
			    write (textBuffer[i]);
			    i := i+1;
			end
		end;

	end { ReportSyntaxError };


    procedure Error(errorCode:  ErrorCodes);
	{ Report errors and abort translation if the error was fatal }
	begin
	    write('line ', nextLineNumber : 1, ': ');

	    case errorCode of
		eExtraneousSource:
		    write('extraneous program text - ignored');
		eIdentifierTooLong:
		    write('warning, identifier truncated');
		eIllegalChar:
		    write('illegal character - deleted');
		eIntegerOverflow:
		    write('integer too large - truncated');
		eIdentTableOverflow:
		    write('too many identifiers (ident table)');
		eIdentTextOverflow:
		    write('too many identifiers (ident text)');
		eNullString:
		    write('null literal string');
		eOptionsError:
		    write('error in specifying compiler option');
		eParseCallStackOvfl:
		    write('nesting too deep (parse call stack)');
		eTextBufferOverflow:
		    write('identifier or string too long');
		eSyntaxError:
		    begin
			write('syntax error at: ');
			ReportSyntaxError
		    end;
		eCommentEOF:
		    write('unclosed comment');
		eLiteralEOF:
		    write('unclosed literal string');
		eLiteralLine:
		    write('literal string crosses line boundary');
		eNoSeparator:
		    write('separator required between integers and identifiers');
		ePrematureEOF:
		    write('unexpected end of file');
	    end { case errorCode };

	    writeln;

	    errorCount := errorCount + 1;

	    if (errorCount > maxErrors) or
	       (errorCode <= lastAbortCode) then
		begin
		    write('translation aborted');
		    writeln;
		    parsing := false;
		    abort := true;
		end;

	end { Error };


    procedure IdentCompare(identReference : IdentTableReference;
			  var found : Boolean);
	{ Compare the identifier just read to an entry in identText,
	  setting found to true if they match, false otherwise. }
	var
	    i :  1 .. textBufferSize;
	    j :  IdentTextReference;
	    charsToCompare :  1 .. maxIdentifierLength;

	begin
	    if identTokenValue[identReference] <= 0 then
		{ We are comparing to a keyword, so the entire
		  identifier is significant in the comparison }
		charsToCompare := tokenTextLength
	    else
		{ Compare only the specified number of characters
		  for non-keyword entries.			 }
		charsToCompare := significantChars;

	    found := identLength[identReference] = chr(charsToCompare);

	    if found then	{ lengths match, now compare text }
		begin
		    i := 1;
		    j := identTextIndex[identReference];
		    repeat
			found := identText[j] = textBuffer[i];
			j := j + 1;
			i := i + 1
		    until not found or (i > charsToCompare);
		end

	end { IdentCompare };


    procedure IdentEnter(identReference :  IdentTableReference);
	{ Enter the character representation of the last identifier accepted
	  into the text table and set the text table pointer and ident length
	  fields of the argument ident table entry.			    }
	var 
	    i :  integer;
	    charsToEnter :  1 .. maxIdentifierLength;

	begin
	    numberOfIdents := numberOfIdents + 1;
	    identTextIndex[identReference] := identTextEnd + 1;
	    { The value used to distinguish identifier tokens is the
	      current number of identifiers (standard and user defined)
	      that have been entered in the ident table. Keywords are
	      distinguished from other identifiers by their negative
	      values.						    }
	    identTokenValue[identReference] := 
			numberOfIdents - lastKeywordToken - 1;

	    if identTokenValue[identReference] <= 0 then
		{ A keyword is being entered; enter its full ident
		  regardless of the number of significant characters
		  requested by the user through the options file.   }
		charsToEnter := tokenTextLength
	    else
		{ Enter only as many characters as were requested
		  in options for user-defined identifiers.	 }
		charsToEnter := significantChars;

	    i := 1;
	    repeat
		identTextEnd := identTextEnd + 1;
		identText[identTextEnd] := textBuffer[i];
		i := i + 1
	    until i > charsToEnter;

	    identLength[identReference] := chr(charsToEnter);

	end { IdentEnter };


    procedure IdentLookup;
	{ Lookup the last accepted ident in the ident table using a hash
	  function.  If the ident is not in the table enter it.	     }
	const
	    firstCharBitShift = 128;
	    lastCharBitShift = 16;
	var
	    found :  Boolean;

	begin
	    { Hashing of all identifiers, user-defined and keywords,
	      must use only the number of significant characters
	      specified in options.  IdentCompare handles the case
	      of keywords which happen to exceed the significance limit.}
	    hashValue := ((ord(textBuffer[1]) * firstCharBitShift)
		      + (ord(textBuffer[significantChars]) * lastCharBitShift)
		      + significantChars) mod identTableSize + 1;
	    repeat
		if identTextIndex[hashValue] = null then	{ a new ident }
		    if (identTextSize - identTextEnd < tokenTextLength) then
			Error(eIdentTextOverflow)
		    else
			begin
			    IdentEnter(hashValue);
			    found := true;
			end
		else if (numberOfIdents >= identTableSize) then
		    Error(eIdentTableOverflow)
		else
		    begin
			IdentCompare(hashValue, found);
			if not found then
			    { The secondary hash must also use the
			      number of significant characters in 
			      the identifier.			  }
			    hashValue := (hashValue + significantChars)
				    mod identTableSize + 1
		    end;
	    until found;

	end { IdentLookup };


    procedure AcceptScanToken;
	{ Read the next character from the source program text (if any
	  remain) and determine the lexical token class to which it belongs. }
	var acceptedScanToken : CharClass;
	begin
	    acceptedScanToken := scanToken;
	    lastInputChar := inputChar;
	    { Get a character from the input stream, placing its character
	      representation in inputChar and its class value in scanToken.}
	    if eof(source) then
		scanToken := lEndFile
	    else if eoln(source) then
		begin
		    readln(source);
		    scanToken := lNewLine
		end
	    else
		begin
		    read(source, inputChar);
		    scanToken := charClassMap[ord(inputChar)];
		end;

	    if scantracing then
		begin
		    write ('Input token accepted ', acceptedScanToken: 1,
			';  Line ', lineNumber: 1, ';  Next scan token ',
			scanToken: 1);
		    if (scanToken <> lEndFile) and (scanToken <> lNewLine) then
			write (' "', inputChar, '"');
		    writeln
		end

	end { AcceptScanToken };


    procedure Initialize;
	{ Set up the charClassMap, initialize the scanner and parser
	  S/SL tables, insert keywords and predeclared identifiers in
	  the ident table and set any requested options.		    }
	var
	    i :  integer;
	    c :  char;

	begin
	    { Get UNIX argument file idents}
	    {
	    argv (1, NstdIdentifiers);
	    argv (2, NscanSsl);
	    argv (3, NparseSsl);
	    argv (4, Nsource);
	    argv (5, NparseStream);
	    argv (6, Noptions);
	    }

	    errorCount := 0;
	    lineNumber := 1;
	    nextLineNumber := 1;
	    newInputLine := false;
	    abort := false;

	    { Initialize charClassMap }
	    i := 0;
	    while i <= charSetSize do
		begin
		    charClassMap[i] := lIllegal;
		    i := i + 1
		end;

	    { N.B. The following code assumes that decimal digit
	      characters (this remark applies also to upper and
	      lower case alphabetic characters) are consecutive
	      in the collating sequence.  If this is not a valid
	      assumption for the character set at hand, then the
	      code must be modified to classify only the appropriate
	      characters as members of the digit (letter) class.    }
	    Assert((ord('9') - ord('0') = 9), assert14);
	    i := ord('0');
	    repeat
		charClassMap[i] := lDigit;
		i := i + 1
	    until i > ord('9');

	    Assert((ord('Z') - ord('A') = 25), assert15);
	    i := ord('A');
	    repeat
		charClassMap[i] := lLetter;
		i := i + 1
	    until i > ord('Z');

	    Assert((ord('z') - ord('a') = 25), assert16);
	    i := ord('a');
	    repeat
		charClassMap[i] := lLetter;
		i := i + 1
	    until i > ord('z');

	    charClassMap[ord(tab)] := lTab;
	    charClassMap[ord(blank)] := lBlank;
	    charClassMap[ord(quote)] := lQuote;
	    charClassMap[ord('(')] := lLeftParen;
	    charClassMap[ord(')')] := lRightParen;
	    charClassMap[ord('*')] := lStar;
	    charClassMap[ord('+')] := lPlus;
	    charClassMap[ord(',')] := lComma;
	    charClassMap[ord('-')] := lMinus;
	    charClassMap[ord('.')] := lDot;
(********** ADDED *)
	    charClassMap[ord('/')] := lSlash;
	    charClassMap[ord('#')] := lHash;
	    charClassMap[ord('@')] := lAtSign;
	    charClassMap[ord('!')] := lExclamation;
(**********)
	    charClassMap[ord(':')] := lColon;
	    charClassMap[ord(';')] := lSemicolon;
	    charClassMap[ord('<')] := lLeftAngle;
	    charClassMap[ord('=')] := lEquals;
	    charClassMap[ord('>')] := lRightAngle;
	    charClassMap[ord('[')] := lLeftBracket;
	    charClassMap[ord(']')] := lRightBracket;
	    charClassMap[ord('{')] := lLeftBrace;
	    charClassMap[ord('}')] := lRightBrace;

	    { Initialize the scan ssl table }
	    reset(scanSsl {, NscanSsl} );
	    i := 0;
	    while not eof(scanSsl) do
		begin
		    if i > scanTableSize then
			Assert(false, assert2);
		    read(scanSsl, scanTable[i]);
		    i := i + 1
		end;

	    { Initialize the parse ssl table }
	    reset(parseSsl {, NparseSsl} );
	    i := 0;
	    while not eof(parseSsl) do
		begin
		    if i > parseTableSize then
			Assert(false, assert3);
		    read(parseSsl, parseTable[i]);
		    i := i + 1
		end;

	    { Accept options }
	    scantracing := false;
	    parsetracing := false;
	    significantIdentTextSize := maxIdentifierLength;
	    reset (options {, Noptions} );

	    while not eof(options) do
		begin
		    read (options, c);
		    if c = 't' then
			begin
			    read (options, c);
			    scantracing := (c = '1');
			    parsetracing := (c = '2');
			end
		    else if (c >= '0') and (c <= '9') then
			begin
			    significantIdentTextSize := ord(c) - ord('0');
			    read(options, c);
			    significantIdentTextSize := significantIdentTextSize
						* 10 + ord(c) - ord('0');
			    if (significantIdentTextSize < minSignificantChars) or
			       (significantIdentTextSize > maxIdentifierLength) then
				begin
				    Error(eOptionsError);
				    significantIdentTextSize := maxIdentifierLength
				end
			end
		end;

	    { Initialize the ident table }
	    i := 1;
	    while i <= identTableSize do
		begin
		    identTextIndex[i] := null;
		    identTokenValue[i] := null;
		    i := i + 1
		end;

	    { The standard identifiers file contains the text of all
	      keywords and predeclared identifiers.  Each identifier 
	      is followed by a newline marker.  Keywords are assumed
	      to precede predeclared identifiers and the order of
	      the keywords in the file must match the order in the
	      parser's keyword token list in parser.ssl .	    }
	    reset(stdIdentifiers {, NstdIdentifiers });
	    numberOfIdents := 0;
	    identTextEnd := 0;
	    i := 0;
	    while (i <= numberStdIdentifiers) and not eof(stdIdentifiers) do
		begin
		    tokenTextLength := 0;
		    while not eoln(stdIdentifiers) do
			begin
			    tokenTextLength := tokenTextLength + 1;
			    read(stdIdentifiers, textBuffer[tokenTextLength]);
			end;

		    { Strip trailing spaces in stdIdentifiers }
		    while (tokenTextLength > 0) and (textBuffer[tokenTextLength] = ' ') do
		        tokenTextLength := tokenTextLength - 1;

		    if tokenTextLength > significantIdentTextSize then
			significantChars := significantIdentTextSize
		    else
			significantChars := tokenTextLength;

		    { Ignore blank lines and comments in stdIdentifiers }
		    if (tokenTextLength <> 0) and (textBuffer[1] <> '%') then
		        begin
			    IdentLookup;
			    i := i + 1;
			end;

		    readln(stdIdentifiers);
		end;

	    { If this assertion fails, you forgot to change numberStdIdentifiers above
	      to agree with the new number of standard identifiers in your stdIdentifiers file }
	    Assert((eof(stdIdentifiers) and (i = numberStdIdentifiers)), assert17);

	    { Initialize scanner table walker }
	    scanTablePointer := 0;
	    scanCallStackTop := 0;

	    { Prepare input of PT source program and output of parse stream }
	    reset(source {, Nsource} );
	    inputChar := blank;
	    AcceptScanToken;
	    rewrite(parseStream {, NparseStream} );

	end { Initialize };


    procedure ScreenIdentifier;
	{ Enforce limits on the number of significant characters in
	  identifiers, enter identifiers into the ident table and
	  distinguish keywords from other identifiers.		  }
	var
	    i :	integer;

	begin
	    if tokenTextLength > maxIdentifierLength then
		begin
		    Error(eIdentifierTooLong);
		    tokenTextLength := maxIdentifierLength
		end;

	    { Mark the number of significant characters in the
	      text buffer for use in IdentLookup, IdentEnter and
	      IdentCompare.					}
	    if tokenTextLength > significantIdentTextSize then
		significantChars := significantIdentTextSize
	    else
		significantChars := tokenTextLength;

	    { Convert all identifiers letters to lower case 
	      since upper and lower case are considered equivalent. }
	    i := 0;
	    while i < tokenTextLength do
		begin
		    i := i + 1;
		    if (textBuffer[i] >= 'A') and (textBuffer[i] <= 'Z') then
			textBuffer[i] := 
			    chr(ord(textBuffer[i]) - ord('A') + ord('a'));
		end;

	    IdentLookup;

	    if identTokenValue[hashValue] <= 0 then
		{ Replace the identifier token by its keyword value }
		parseInputToken := identTokenValue[hashValue] + lastKeywordToken
	    else
		{ Set the value of a compound user defined identifier token }
		parseTokenValue := identTokenValue[hashValue];

	end { ScreenIdentifier };


    procedure ScreenInteger;
	{ Set the value of an integer token, truncating if
	  it exceeds the maximum implementation values.  }
	var
	    digit :  0 .. 9;
	    i :  1 .. textBufferSize;

	begin
	    parseTokenValue := 0;
	    i := 1;
	    while i <= tokenTextLength do
		begin
		    digit := ord(textBuffer[i]) - ord('0');

		    (*
		    if (parseTokenValue > maxIntDivTen) or
			   ((parseTokenValue = maxIntDivTen) and
			    (digit > maxIntModTen)) then
			{ Integer value is too large }
			begin
			    Error(eIntegerOverflow);
			    parseTokenValue := maxInteger;
			    i := tokenTextLength  { exit the while loop }
			end
		    else
		    *)
			parseTokenValue := parseTokenValue * 10 + digit;

		    i := i + 1
		end

	end { ScreenInteger };


    procedure ScanSSLChoice(choiceTag : integer;
			    var choiceTagMatched : Boolean);
	{ This procedure performs both input and semantic
	  choices.  It sequentially tests each alternative
	  value against the tag value, and when a match is
	  found, performs a branch to the corresponding
	  alternative path.  If none of the alternative
	  values matches the tag value, sslTable interpretation
	  proceeds to the operation immediately following
	  the list of alternatives (normally the otherwise
	  path).  The flag choiceTagMatched is set to true
	  if a match is found and false otherwise.		}
	var
	    numberOfChoices :  integer;

	begin
	    scanTablePointer := scanTablePointer + scanTable[scanTablePointer];
	    numberOfChoices := scanTable[scanTablePointer];
	    scanTablePointer := scanTablePointer + 1;
	    choiceTagMatched := false;

	    while numberOfChoices > 0 do
		begin
		    if scanTable[scanTablePointer] = choiceTag then
			begin
			    scanTablePointer := scanTablePointer + 1;
			    scanTablePointer := 
				scanTablePointer - scanTable[scanTablePointer];
			    choiceTagMatched := true;
			    numberOfChoices := 0;
			end
		    else
			begin
			    scanTablePointer := scanTablePointer + 2;
			    numberOfChoices := numberOfChoices - 1
			end
		end;

	    if scantracing then
		begin
		    write ('Choice tag ', choiceTag : 1);
		    if choiceTagMatched then
			write (' (matched)')
		    else
			write (' (not matched)');
		    writeln
		end

	end { ScanSSLChoice };


    procedure SSLTrace(walkerName : PhaseNames;  tablePointer : integer;
		       operation : integer;  argument : integer);
	begin
            write ('Table index ', tablePointer-1: 1, ';  Operation ',
                operation: 1, ';  Argument ', argument: 1);
            writeln;
	end { SSLTrace };


    procedure Scanner;
	{ The scanner removes token separators from the source program
	  text (blanks, newlines, tabs, comments) and breaks the program
	  up into syntax tokens.  The scanner operates as a coroutine
	  with the parser.  Each time it is activated, it scans a single
	  token before passing control back to the parser.		}
	var
	    scanning :	Boolean;  { termination control }
	    operation :  ScanOperation;
	    choiceTagMatched :  Boolean;

	    { Flag buffer overflows so only a single error message is emitted }
	    textBufferOverflow :  Boolean;


	{ S/SL table walker }
	begin
	    tokenTextLength := 0;
	    scanning := true;
	    textBufferOverflow := false;

	    repeat
		operation := scanTable[scanTablePointer];
		scanTablePointer := scanTablePointer + 1;

		if scantracing then
		    SSLTrace(scan, scanTablePointer, operation,
			     scanTable[scanTablePointer]);

		case operation of
		    oCall:
			if scanCallStackTop < scanCallStackSize then
			    begin
				scanCallStackTop := scanCallStackTop + 1;
				scanCallStack[scanCallStackTop] :=
					scanTablePointer + 1;
				scanTablePointer := scanTable[scanTablePointer];
			    end
			  else
			    { The scanner S/SL contains no
			      recursion so this shouldn't happen }
			    Assert(false, assert4);

		    oReturn:
			if scanCallStackTop > 0 then
			    begin
				scanTablePointer := 
				        scanCallStack[scanCallStackTop];
				scanCallStackTop := scanCallStackTop - 1
			    end
			  else
			    scanning := false;	{ normal exit }

		    oRuleEnd:
			{ No rule choices in scanner }
			Assert(false, assert5);

		    oJumpForward:
			scanTablePointer := scanTablePointer +
				scanTable[scanTablePointer];

		    oJumpBack:
			scanTablePointer := scanTablePointer -
				scanTable[scanTablePointer];

		    oInput:
			{ No forced inputs in scanner }
			Assert(false, assert6);

		    oInputAny:
			if scanToken <> lEndFile then
			    AcceptScanToken
			else
			    { premature end of file }
			    Error(ePrematureEOF);

		    oInputChoice:
			begin
			    ScanSSLChoice(scanToken, choiceTagMatched);
			    if choiceTagMatched then
				AcceptScanToken
			end;

		    oEmit:
			begin
			    parseInputToken := scanTable[scanTablePointer];
			    scanTablePointer := scanTablePointer + 1;
			    { Return control to the parser }
			    scanning := false
			end;

		    oError:
			begin
			    Error (scanTable[scanTablePointer]);
			    scanTablePointer := scanTablePointer + 1;
			end;

		    oChoice:
			{ No choices in scanner }
			Assert(false, assert7);

		    oChoiceEnd:
			Assert(false, assert8);

		    oSetParameter:
			{ No parameterized operations in scanner }
			Assert(false, assert9);

		    oSetResult:
			{ No choice operations in scanner }
			Assert(false, assert10);


		    { Semantic Operations of the Buffer Mechanism }
		    
		    oBufferSave:
			{ Save the last accepted character in
			  a text buffer for later reference. }
			if tokenTextLength < textBufferSize then
			    begin
				tokenTextLength := tokenTextLength + 1;
				textBuffer[tokenTextLength] := lastInputChar
			    end
			else
			    { Set a flag rather than calling Error 
			      to avoid a string of consecutive messages. }
			    textBufferOverflow := true;

		end { case operation };

	    until not scanning;

	    if textBufferOverflow then
		Error(eTextBufferOverflow)

	end { Scanner };


    procedure ScannerScreener;
	{ Invoke the scanner to find the next syntax token in the source
	  program.  The token returned is left in parseInputToken.  The
	  value of a compound token is left in parseTokenValue and the
	  characters comprising a literal string are left in textBuffer.
	  Resolve identifiers and keywords, and enforce limits on
	  identifier lengths and integer values.		      }

	var
	    i : integer;

	begin
	    Scanner;

	    if parseInputToken = pIdentifier then
		ScreenIdentifier
	    else if parseInputToken = pInteger then
		ScreenInteger;

	    if scantracing then
		begin
		    write ('Output token emitted ', parseInputToken: 1);
		    writeln;

		    if (parseInputToken >= firstCompoundInputToken) and
			    (parseInputToken <= lastCompoundInputToken) then
			begin
			    write ('% Output token text ''');
			    i := 1;
			    repeat
				write (textBuffer [i]);
				i := i + 1;
			    until i > tokenTextLength;
			    write ('''');
			    writeln;
			end
		end

	end { ScannerScreener };


    procedure ParseSSLChoice (choiceTag : integer;
			      var choiceTagMatched :  Boolean);
	{ See comment under ScanSSLChoice }
	var
	    numberOfChoices :  integer;

	begin
	    parseTablePointer := 
		parseTablePointer + parseTable[parseTablePointer];
	    numberOfChoices := parseTable[parseTablePointer];
	    parseTablePointer := parseTablePointer + 1;
	    choiceTagMatched := false;

	    while numberOfChoices > 0 do
		begin
		    if parseTable[parseTablePointer] = choiceTag then
			begin
			    parseTablePointer := parseTablePointer + 1;
			    parseTablePointer :=  
				parseTablePointer - parseTable[parseTablePointer];
			    choiceTagMatched := true;
			    numberOfChoices := 0
			end
		    else
			begin
			    parseTablePointer := parseTablePointer + 2;
			    numberOfChoices := numberOfChoices - 1
			end
		end;

	    if parsetracing then
		begin
		    write ('Choice tag ', choiceTag : 1);
		    if choiceTagMatched then
			write (' (matched)')
		    else
			write (' (not matched)');
		    writeln
		end

	end { ParseSSLChoice };


    procedure EmitOutputToken (emittedToken: integer);
	{ Emit an output token to the parse stream }
	var
	    i :  integer;

	begin
	    write (parseStream, emittedToken);

	    if parsetracing then
		begin
		    write ('Output token emitted ', emittedToken: 1);
		    writeln;
		end;

	    { Emit the value associated with a compound token.
	      N.B. this code assumes that the compound token being
	      emitted was the last compound token accepted.	  }
	    if (emittedToken = sIdentifier) or
		   (emittedToken = sInteger) then
		write(parseStream, compoundTokenValue)
	    else if emittedToken = sLiteral then
		{ Emit the text of a literal string token }
		begin
		    write(parseStream, compoundTokenLength);
		    i := 1;
		    while i <= compoundTokenLength do
			begin
			    write(parseStream, ord(compoundTokenText[i]));
			    i := i + 1
			end
		end;

	end { EmitOutputToken };


    procedure AcceptSyntaxToken;
	{ This procedure provides the interface to the
	  ScannerScreener;  it is responsible for handling
	  all input including line number indicators and
	  the values and text associated with input tokens.  }
	var
	    acceptedToken :  SyntaxToken;
	    i :  integer;

	begin
	    Assert(parseInputToken <> pEndFile, assert11);

	    { Accept Token }
	    acceptedToken := parseInputToken;

	    if (acceptedToken >= firstCompoundInputToken) and
		   (acceptedToken <= lastCompoundInputToken) then
		begin
		    compoundToken := acceptedToken;
		    compoundTokenValue := parseTokenValue;
		    compoundTokenLength := tokenTextLength;

		    if acceptedToken = pLiteral then
			begin
			    i := 1;
			    while i <= compoundTokenLength do
				begin
				    compoundTokenText[i] := textBuffer[i];
				    i := i + 1
				end
			end
		end;

	    { Update Line Number }
	    lineNumber := nextLineNumber;

	    { Read Next Input Token }
	    newInputLine := false;
	    repeat
		ScannerScreener;

		if parseInputToken = pNewLine then
		    begin
			{ Update Line Counter and Set Flag }
			newInputLine := true;

			if nextLineNumber < maxLineNumber then
			    nextLineNumber := nextLineNumber + 1
			else
			    nextLineNumber := 0;

			{ Pass line markers to the next pass }
			EmitOutputToken(sNewLine);
		    end;
	    until parseInputToken <> pNewLine;

	    if parsetracing then
		begin
		    write ('Input token accepted ', acceptedToken: 1,
			';  Line ', lineNumber: 1, ';  Next input token ',
			parseInputToken: 1);
		    writeln
		end

	end { AcceptSyntaxToken };


    { Syntax Error Handling }

    procedure SslGenerateCompoundInputToken (expectedToken: SyntaxToken);
	begin
	    Assert ((parseInputToken = pSyntaxError) or
		    (parseInputToken = pEndFile), assert12);

	    case expectedToken of
		pInteger:
		    compoundTokenValue := 0;
		pIdentifier:
		    compoundTokenValue := defaultIdentifier;
		pLiteral:
		    begin
			compoundTokenLength := 1;	{ literal length }
			compoundTokenText[1] := '?';
		    end
	    end;

	end { SslGenerateCompoundInputToken };


    procedure SslSyntaxError;
	{ This procedure handles syntax errors in the input
	  to the Parser pass; for Semantic passes this procedure
	  will simply assert false since a syntax error in
	  input would indicate an error in the previous pass.    }

	{ Syntax error recovery:
	  When a mismatch occurs between the the next input 
	  token and the syntax table, the following recovery
	  is employed.						}

	{ If the expected token is pNewLine then if there
	  has been no previous syntax error on the line,
	  ignore the error.  (A missing logical new line
	  is not a real error.)					}

	{ If the expected token is pNewLine or pSemicolon and
	  a syntax error has already been detected on the
	  current logical line (flagged by parseInputToken =
	  pSyntaxError), then flush the input until a
	  new line or end of file is found.			}

	{ Otherwise, if this is the first syntax error
	  detected on the line (flagged by parseInputToken
	  <> pSyntaxError), then if the input token
	  is pEndFile then emit the ePrematureEOF
	  error code and terminate execution.  Otherwise,
	  emit the eSyntaxError error code and set
	  the parseInputToken to pSyntaxError to prevent
	  further input until the expected input is
	  pSemicolon or pNewLine.				}

	{ If the expected token is not pSemicolon nor
	  pNewLine and a syntax error has already been
	  detected on the current line (flagged by
	  parseInputToken = pSyntaxError), then do nothing
	  and continue as if the expected token had
	  been matched.					}

	begin
	    Assert ((parserOperation = oInput) or
		    (parserOperation = oInputAny), assert13);

	    if parseInputToken = pSyntaxError then
		begin
		    { Currently recovering from syntax error }
		    if parseTable[parseTablePointer] = pSemicolon then
			begin
			    { Complete recovery by synchronizing
			     input to a new line		 }
			    parseInputToken := savedInputToken;
			    newInputLine := false;

			    while (parseInputToken <> pSemicolon) and
				  (parseInputToken <> pEndFile) and
				  not newInputLine do
				AcceptSyntaxToken;

			    { If we now have the expected token, accept it }
			    if parseInputToken = pSemicolon then
				AcceptSyntaxToken;
			end;
		end
	    else
		{ First syntax error on the line }
		if parseInputToken = pEndFile then
		    begin
			{ Flag error and terminate parsing }
			Error (ePrematureEOF);
			parsing := false;
		    end
		else
		    begin
			{ Flag error and begin recovery }
			Error (eSyntaxError);
			savedInputToken := parseInputToken;
			parseInputToken := pSyntaxError;
			lineNumber := nextLineNumber;
		    end;

	    { If the expected input token is a compound 
	     token, generate a dummy one.		}
	    if (parseTable[parseTablePointer] >= firstCompoundInputToken) and
		   (parseTable[parseTablePointer] <= lastCompoundInputToken) then
		SslGenerateCompoundInputToken (parseTable[parseTablePointer]);

	end { SslSyntaxError };


    procedure Parser;
	{ The parser checks that the source program is syntactically legal,
	  flagging syntax errors and repairing them. The parser passes
	  control to the Scanner (the Scanner and Parser are coroutines)
	  whenever it requires a new token.  It emits a stream representing
	  the parsed program in postfix form to the semantic pass.	   }
	const
	    parseCallStackSize = 63;
	var
	    { Parameterized And Choice Semantic Operation Values:
	      These are used to hold the decoded parameter value to
	      a parameterized semantic operation and the result
	      value returned by a choice semantic operation
	      or rule respectively.					 }
	    parameterValue :  integer;
	    resultValue :  integer;

	    { Flag for result of choices }
	    choiceTagMatched :  Boolean;

	    { Saved return addresses for S/SL call operations }
	    parseCallStack :  array [1 .. parseCallStackSize] of integer;
	    parseCallStackTop :  0 .. parseCallStackSize;

	begin
	    { Initialize Parse Table Walker State }
	    parsing := true;
	    parseTablePointer := 0;
	    parseCallStackTop := 0;

	    { Initialize token input from Scanner }
	    parseInputToken := pNewLine;
	    newInputLine := false;
	    AcceptSyntaxToken;

	    { Walk the S/SL Table }
	    while parsing do
		begin
		    parserOperation := parseTable[parseTablePointer];
		    parseTablePointer := parseTablePointer + 1;

		    { Trace Execution }
		    if parsetracing then
			SSLTrace(parse, parseTablePointer, parserOperation,
				 parseTable[parseTablePointer]);

		    case parserOperation of
			oCall:
			    if parseCallStackTop < parseCallStackSize then
				begin
				    parseCallStackTop := parseCallStackTop + 1;
				    parseCallStack[parseCallStackTop] :=
					parseTablePointer + 1;
				    parseTablePointer := 
					parseTable[parseTablePointer];
				end
			      else
				begin
				    Error (eParseCallStackOvfl);
				    parsing := false;
				end;

			oReturn:
			    if parseCallStackTop = 0 then
				{ Return from main S/SL rule }
				parsing := false
			    else
				begin
				    parseTablePointer :=
					parseCallStack[parseCallStackTop];
				    parseCallStackTop := parseCallStackTop - 1;
				end;

			oRuleEnd:
			    SslFailure (fChoiceRuleFailed);

			oJumpForward:
			    parseTablePointer := parseTablePointer +
				parseTable[parseTablePointer];

			oJumpBack:
			    parseTablePointer := parseTablePointer -
				parseTable[parseTablePointer];

			oInput:
			    begin
				if parseTable[parseTablePointer] =
					parseInputToken then
				    AcceptSyntaxToken
				else
				    { Syntax error in input }
				    SslSyntaxError;

				parseTablePointer := parseTablePointer + 1;
			    end;

			oInputAny:
			    if parseInputToken <> pEndFile then
				AcceptSyntaxToken
			    else
				{ Premature end of file }
				SslSyntaxError;

			oInputChoice:
			    begin
				ParseSSLChoice (parseInputToken, choiceTagMatched);

				if choiceTagMatched then
				    AcceptSyntaxToken;
			    end;

			oEmit:
			    begin
				EmitOutputToken (parseTable[parseTablePointer]);
				parseTablePointer := parseTablePointer + 1;
			    end;

			oError:
			    begin
				Error (parseTable[parseTablePointer]);
				parseTablePointer := parseTablePointer + 1;
			    end;

			oChoice:
			    ParseSSLChoice (resultValue, choiceTagMatched);

			oChoiceEnd:
			    SslFailure (fSemanticChoiceFailed);

			oSetParameter:
			    begin
				parameterValue := parseTable[parseTablePointer];
				parseTablePointer := parseTablePointer + 1;
			    end;

			oSetResult:
			    begin
				resultValue := parseTable[parseTablePointer];
				parseTablePointer := parseTablePointer + 1;
			    end;

		    end { case parserOperation };

		end { while parsing };

	    if (parseInputToken <> pEndFile) and not abort then
		Error (eExtraneousSource);

	end { Parser };


    { Main program ScannerParser }
    begin
	Initialize;
	Parser;
	{ No sense running semantic phase if serious syntax errors found }
	if errorCount > 0 then
	    rewrite(parseStream {, NparseStream} );
    end.  { ScannerParser }
