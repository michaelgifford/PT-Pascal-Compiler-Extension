{  PT Semantic Analysis Pass   Ver.  1.08

   Abstract:
     The semantic analysis pass builds the symbol and type tables.  It
   enforces context sensitive syntax restrictions such as "declaration
   before use".  It performs type checking between assignment L and R
   values, between expression operands and operators, between formal
   and actual parameters.  It assigns runtime addresses to data objects.
   It emits a stream of PT pseudo code, tCode, to implement the program.

   Input Files

	semanticSsl:  The S/SL table which drives the program

	parseStream:  Semantic tokens emitted by the parser

	options:  Semantic pass options


   Input Output Files

	temp:  Tcode is emitted to this file as it is generated.  The file
	       is read later to back-patch the tCode.


   Output Files

	tCode:  Tcode generated for the source program

	output:  Diagnostic messages.

}


program SemanticAnalysis (output, semanticSsl, parseStream, temp, tCode, options);

    const
	{ S/SL Table Walker Operations }
	{ Primitive S/SL Table Operations }
	oCall = 0;
	oReturn = 1;
	oRuleEnd = 2;
	oJumpBack = 3;
	oJumpForward = 4;
	oInput = 5;
	oInputAny = 6;
	oInputChoice = 7;
	oEmit = 8;
	oError = 9;
	oChoice = 10;
	oChoiceEnd = 11;
	oSetParameter = 12;
	oSetResult = 13;

{ ===== Pasted contents of semantic.def, generated by S/SL from semantic.ssl -
	defines Semantic Operations, Input/Output Tokens, Error Codes and Semantic Types }

(********** CHANGED *)
	{ Semantic Operations }
	oSymbolTblEnter = 14;
	oSymbolTblUpdate = 15;
	oSymbolTblPushScope = 16;
	oSymbolTblPopScope = 17;
	oSymbolTblLookupExternal = 18; { >>14 }
	oSymbolTblStripScope = 19;
	oSymbolTblMergeScope = 20;
	oSymbolStkPush = 21; { (17) }
	oSymbolStkPushIdentifier = 22;
	oSymbolStkPushLocalIdentifier = 23;
	oSymbolStkPushStandardVariable = 24; { (19) }
	oSymbolStkPushFormalParameter = 25;
	oSymbolStkSetKind = 26; { (17) }
	oSymbolStkLinkToStandardType = 27; { (16) }
	oSymbolStkEnterValue = 28;
	oSymbolStkEnterStringValue = 29;
	oSymbolStkEnterCodeAddress = 30;
	oSymbolStkEnterDataAddress = 31;
	oSymbolStkEnterTypeReference = 32;
	oSymbolStkChooseKind = 33; { >>17 }
	oSymbolStkChooseStandardFile = 34; { >>19 }
	oSymbolStkChooseStandardRoutine = 35; { >>18 }
	oSymbolStkPop = 36;
	oTypeTblEnter = 37;
	oTypeTblUpdate = 38;
	oTypeStkPush = 39; { (20) }
	oTypeStkPushSymbol = 40;
	oTypeStkPushComponent = 41;
	oTypeStkSetKind = 42; { (20) }
	oTypeStkSetRecursionFlag = 43; { (14) }
	oTypeStkChooseRecursionFlag = 44; { >>14 }
	oTypeStkSetPackedComponentFlag = 45; { (14) }
	oTypeStkChoosePackedComponentFlag = 46; { >>14 }
	oTypeStkLinkToStandardComponentType = 47; { (16) }
	oTypeStkEnterBounds = 48;
	oTypeStkVerifyBounds = 49; { >>14 }
	oTypeStkEnterParameterCount = 50;
	oTypeStkCompareParameterCount = 51; { >>14 }
	oTypeStkEnterComponentReference = 52;
	oTypeStkChooseKind = 53; { >>20 }
	oTypeStkChooseTypeReference = 54; { >>14 }
	oTypeStkCompareNames = 55; { >>14 }
	oTypeStkSwap = 56;
	oTypeStkPop = 57;
	oEmitNullAddress = 58;
	oEmitValue = 59;
	oEmitString = 60;
	oEmitDataAddress = 61;
	oEmitTrapKind = 62; { (21) }
	oEmitCaseBranchTable = 63;
	oAllocateAlignOnWord = 64;
	oAllocateVariable = 65;
	oAllocateVarParameter = 66;
	oAllocateDescriptor = 67;
	oValuePush = 68; { (13) }
	oValuePushInteger = 69;
	oValuePushStringLength = 70;
	oValuePushSymbol = 71;
	oValuePushCount = 72;
	oValuePushTypeStkLowerBound = 73;
	oValuePushTypeStkUpperBound = 74;
	oValueNegate = 75;
	oValueChoose = 76; { >>13 }
	oValuePop = 77;
	oCasePushDisplay = 78;
	oCasePopDisplay = 79;
	oCaseLookupLabel = 80; { >>14 }
	oCasePushLabel = 81;
	oCountPush = 82; { (13) }
	oCountPushValue = 83;
	oCountPop = 84;
	oCountIncrement = 85;
	oCountDecrement = 86;
	oCountChoose = 87; { >>13 }
	oFixPushForwardBranch = 88;
	oFixPopForwardBranch = 89;
	oFixPushTargetAddress = 90;
	oFixPopTargetAddress = 91;
	oFixPopAndEnterValue = 92;
	oFixSwap = 93;

	{ Input Tokens }
	sIdentifier = 0;
	firstInputToken = 0;
	sInteger = 1;
	sLiteral = 2;
	sProgram = 3;
	sParmBegin = 4;
	sParmEnd = 5;
	sConst = 6;
	sType = 7;
	sVar = 8;
	sProcedure = 9;
	sPublic = 10;
	sBegin = 11;
	sEnd = 12;
	sNegate = 13;
	sArray = 14;
	sPacked = 15;
	sFile = 16;
	sRange = 17;
	sCaseStmt = 18;
	sDefault = 19;
	sCaseEnd = 20;
	sLabelEnd = 21;
	sExpnEnd = 22;
	sNullStmt = 23;
	sAssignmentStmt = 24;
	sSubscript = 25;
	sCallStmt = 26;
	sFieldWidth = 27;
	sIfStmt = 28;
	sThen = 29;
	sElse = 30;
	sClass = 31;
	sLoopStmt = 32;
	sLoopBreakWhen = 33;
	sLoopEnd = 34;
	sReturn = 35;
	sEq = 36;
	sNE = 37;
	sLT = 38;
	sLE = 39;
	sGT = 40;
	sGE = 41;
	sAdd = 42;
	sSubtract = 43;
	sMultiply = 44;
	sDivide = 45;
	sModulus = 46;
	sInfixOr = 47;
	sOr = 48;
	sInfixAnd = 49;
	sAnd = 50;
	sNot = 51;
	sSubstring = 52;
	sLength = 53;
	sNewLine = 54;
	sEndOfFile = 55;
	lastInputToken = 55;

	{ Output Tokens }
	tMultiply = 0;
	firstOutputToken = 0;
	tDivide = 1;
	tModulus = 2;
	tAdd = 3;
	tSubtract = 4;
	tEQ = 5;
	tNE = 6;
	tGT = 7;
	tGE = 8;
	tLT = 9;
	tLE = 10;
	tAnd = 11;
	tInfixAnd = 12;
	tOr = 13;
	tInfixOr = 14;
	tNegate = 15;
	tNot = 16;
	tChr = 17;
	tOrd = 18;
	tEoln = 19;
	tEOF = 20;
	tVarParm = 21;
	tFetchAddress = 22;
	tFetchInteger = 23;
	tFetchString = 24;
	tFetchBoolean = 25;
	tAssignBegin = 26;
	tAssignAddress = 27;
	tAssignInteger = 28;
	tAssignString = 29;
	tAssignBoolean = 30;
	tStoreParmAddress = 31;
	tStoreParmInteger = 32;
	tStoreParmString = 33;
	tStoreParmBoolean = 34;
	tSubscriptBegin = 35;
	tSubscriptAddress = 36;
	tSubscriptInteger = 37;
	tSubscriptString = 38;
	tSubscriptBoolean = 39;
	tArrayDescriptor = 40;
	tFileDescriptor = 41;
	tIfBegin = 42;
	tIfEnd = 43;
	tCaseBegin = 44;
	tLoopBegin = 45;
	tLoopBreakWhen = 46;
	tCallBegin = 47;
	tParmEnd = 48;
	tProcedureEnd = 49;
	tWriteBegin = 50;
	tReadBegin = 51;
	tTrapBegin = 52;
	tWriteEnd = 53;
	tReadEnd = 54;
	tCaseElse = 55;
	tConcatenate = 56;
	tSubstring = 57;
	tLength = 58;
	tStringEqual = 59;
	tFunctionResult = 60;
	tLiteralAddress = 61;
	firstCompoundOutputToken = 61;
	tLiteralInteger = 62;
	tLiteralBoolean = 63;
	tLiteralString = 64;
	tStringDescriptor = 65;
	tSkipString = 66;
	tIfThen = 67;
	tIfMerge = 68;
	tCaseSelect = 69;
	tCaseMerge = 70;
	tCaseEnd = 71;
	tLoopTest = 72;
	tLoopEnd = 73;
	tSkipProc = 74;
	tCallEnd = 75;
	tLineNumber = 76;
	tTrap = 77;
	lastCompoundOutputToken = 77;
	tEndOfFile = 78;
	lastOutputToken = 78;

	{ Input/Output Tokens }

	{ Error Codes }
	eDuplicateName = 10;
	firstErrorCode = 10;
	eMultiplyDefined = 11;
	eUndefinedIdentifier = 12;
	eConstantReqd = 13;
	eNullString = 14;
	eSubrangeReqd = 15;
	eScalarReqd = 16;
	eIntegerConstReqd = 17;
	eBounds = 18;
	eSimpleTypeReqd = 19;
	eExternalUndeclared = 20;
	eExternalDeclare = 21;
	eFileVarReqd = 22;
	eFileNameReqd = 23;
	eOperandOperatorTypeMismatch = 24;
	eNonScalarValParm = 25;
	eParameterTypeMismatch = 26;
	ePackedComponentByVar = 27;
	eInsufficientActuals = 28;
	eExtraActuals = 29;
	eRecursiveCall = 30;
	eIllegalFunctionType = 31;
	eProcedureReqd = 32;
	eTypeIdentifierReqd = 33;
	eIntegerExpnReqd = 34;
	eBooleanExpnReqd = 35;
	eStringExpnReqd = 36;
	eArrayVarReqd = 37;
	eVariableReqd = 38;
	eDuplicateLabel = 39;
	eExpnOperandReqd = 40;
	eTypeMismatch = 41;
	eInvalidExpn = 42;
	eInputNotVisible = 43;
	eOutputNotVisible = 44;
	eFieldWidth = 45;
	eStringFileVarReqd = 46;
	eWriteExpn = 47;
	eReadVar = 48;
	lastSslErrorCode = 48;

	{ Type Values }
	{ Type 13 }
	zero = 0;
	one = 1;
	two = 2;
	three = 3;
	ten = 10;
	byteSize = 1;
	wordSize = 4;
	stringSize = 1024;
	{ Type 14 }
	no = 0;
	yes = 1;
	{ Type 15 }
	firstPredeclaredId = 1;
	firstPredeclaredType = 1;
	pidInteger = 1;
	pidString = 2;
	pidBoolean = 3;
	pidText = 4;
	lastPredeclaredType = 4;
	pidTrue = 5;
	pidFalse = 6;
	pidReset = 7;
	pidRewrite = 8;
	pidWrite = 9;
	pidWriteln = 10;
	pidRead = 11;
	pidReadln = 12;
	pidChr = 13;
	pidOrd = 14;
	pidEoln = 15;
	pidEof = 16;
	pidAssign = 17;
	lastPredeclaredId = 17;
	pidInput = 18;
	firstSpecialId = 18;
	pidOutput = 19;
	lastSpecialId = 19;
	{ Type 16 }
	stdInteger = 0;
	stdString = 1;
	stdBoolean = 2;
	stdText = 3;
	{ Type 17 }
	syConstant = 0;
	syType = 1;
	syVariable = 2;
	syVarParameter = 3;
	syProcedure = 4;
	syFunction = 5;
	syClass = 6;
	syPublicProcedure = 7;
	syPublicFunction = 8;
	syExternal = 9;
	syExpression = 10;
	syUndefined = 11;
	{ Type 18 }
	rtReset = 1;
	rtRewrite = 2;
	rtWrite = 3;
	rtWriteln = 4;
	rtRead = 5;
	rtReadln = 6;
	rtOrd = 7;
	rtChr = 8;
	rtEoln = 9;
	rtEof = 10;
	rtAssign = 11;
	rtNull = 12;
	{ Type 19 }
	stdInput = 0;
	stdOutput = 1;
	stdNull = 2;
	{ Type 20 }
	tpInteger = 0;
	tpString = 1;
	tpBoolean = 2;
	tpSubrange = 3;
	tpArray = 4;
	tpPackedArray = 5;
	tpFile = 6;
	tpNull = 7;
	{ Type 21 }
	trHalt = 0;
	trReset = 1;
	trRewrite = 2;
	trRead = 3;
	trReadln = 4;
	trWrite = 5;
	trWriteln = 6;
	trWriteInteger = 8;
	trReadInteger = 10;
	trAssign = 12;
	trWriteString = 108;
	trReadString = 107;

	{ S/SL Rule Table Addresses } {
	Program = 0;
	ProgramParameter = 41;
	Block = 101;
	AllocateVar = 923;
	ProcedureDefinition = 1001;
	ClassDefinition = 143;
	ConstantDefinitions = 181;
	TypeDefinitions = 321;
	VariableDeclarations = 729;
	BeginStmt = 1504;
	ConstantValue = 186;
	SymbolStkPushIntegerConstant = 4338;
	TypeBody = 385;
	IndexType = 462;
	ComponentType = 508;
	SimpleType = 557;
	ValuePushValuePlusOne = 4329;
	SymbolStkPushIntegerType = 4362;
	SubrangeUpperBound = 667;
	VariableAttributes = 778;
	ProcedureHeading = 1098;
	FunctionReturnType = 1215;
	FunctionReturnValue = 1267;
	ProcedureParameterType = 1144;
	ProcedurePrologue = 1325;
	Expression = 2014;
	CountCopy = 4334;
	Statement = 1394;
	AssignmentStmt = 1442;
	CallStmt = 1518;
	IfStmt = 1783;
	CaseStmt = 1839;
	LoopStmt = 1814;
	Variable = 2607;
	CompareAndSwapTypes = 2411;
	OpenProcedure = 3064;
	AssignProcedure = 3133;
	WriteProcedure = 3238;
	WritelnProcedure = 3713;
	ReadProcedure = 3825;
	ReadlnProcedure = 4187;
	ActualParameters = 1653;
	FlushActuals = 4402;
	VariableActual = 1721;
	BooleanControlExpression = 4314;
	CaseSelectorExpression = 4297;
	CaseElse = 2003;
	CaseAlternative = 1899;
	Operand = 2044;
	UnaryOperator = 2136;
	BinaryOperator = 2187;
	TernaryOperator = 2363;
	FlushExpn = 4381;
	ConstantOperand = 2741;
	VariableOperand = 2781;
	FunctionOperand = 2808;
	SymbolStkPushIntegerVariable = 4369;
	FileOperand = 3039;
	CompareOperandAndResultTypes = 2511;
	CompareEqualityRelationalOperandTypes = 2557;
	CompareRelationalOperandTypes = 2522;
	VariableExtension = 2649;
	StandardFunctionActual = 2944;
	WriteString = 3505;
	WriteNonString = 3629;
	WriteStandardExpnList = 3459;
	ReadStringParameterList = 3955;
	ReadNonStringParameterList = 4021;
	ReadString = 4087;
	ReadNonString = 4116;
	SymbolStkPushStringConstant = 4350;
	}

	{ S/SL Table Parameters }
	sslTblSize = 4421;
	minSslTableValue = -32767;
	maxSslTableValue = 32767;
{**********)

{ ===== End of contents of semantic.def }

	{ firstFatalErrorCode MUST be bigger than lastSslErrorCode }
	firstFatalErrorCode = 50;
	eSslStackOverflow = 50;
	eSymbolTblOvfl = 51;
	eSymbolStkOvfl = 52;
	eTypeTblOvfl = 53;
	eTypeStkOvfl = 54;
	eCountStackOvfl = 55;
	eFixStackOvfl = 56;
	eValueStackOvfl = 57;
	eCaseDisplayOvfl = 58;
	eCaseRange = 59;
	eCaseStackOvfl = 60;
	eLexicLevelStackOvfl = 61;
	ePatchTableOvfl = 62;
	eIdentTableOvfl = 63;
	lastErrorCode = 63;

	{ S/SL System Failure Codes }
	firstFailureCode = 0;
	fSemanticChoiceFailed = 0;
	fChoiceRuleFailed = 1;
	lastFailureCode = 1;

	{ Assertion statement identification values. }
	assert1 = 1;
	assert2 = 2;
	assert3 = 3;
	assert4 = 4;
	assert5 = 5;
	assert6 = 6;
	assert7 = 7;
	assert8 = 8;
	assert9 = 9;
	assert10 = 10;
	assert11 = 11;
	assert12 = 12;
	assert13 = 13;
	assert14 = 14;
	assert15 = 15;
	assert16 = 16;
	assert17 = 17;
	assert18 = 18;
	assert19 = 19;
	assert20 = 20;
	assert21 = 21;
	assert22 = 22;
	assert23 = 23;
	assert24 = 24;
	assert25 = 25;
	assert26 = 26;
	assert27 = 27;
	assert28 = 28;
	assert29 = 29;
	assert30 = 30;
	assert31 = 31;
	assert32 = 32;
	assert33 = 33;
	assert34 = 34;
	assert35 = 35;
	assert36 = 36;
	assert37 = 37;
	assert38 = 38;
	assert39 = 39;
	assert40 = 40;
	assert41 = 41;
	assert42 = 42;
	assert43 = 43;
	assert44 = 44;
	assert45 = 45;
	assert46 = 46;
	assert47 = 47;
	assert48 = 48;
	assert49 = 49;
	assert50 = 50;
	assert51 = 51;
	assert52 = 52;
	assert53 = 53;
	assert54 = 54;
	assert55 = 55;
	assert56 = 56;
	assert57 = 57;
	assert58 = 58;

	{ The S/SL Rule Call Stack Size }
	sslStackSize = 127;

	{ Maximum Source Lines }
	maxLineNumber = 9999;

	{ Maximum Error Count }
	maxErrors = 20;

	{ Semantic data structure sizes }
	{ Our ident table size must be at least as large as the corresponding
	  constant in the Scanner/Parser. }
	identTblSize = 1601;
	symbolTblSize = 1500;
	typeTblSize = 350;
	lexicLevelStackSize = 14;	{ limits procedure nesting }
	symbolStkSize = 40;
	typeStkSize = 60;
	caseDisplaySize = 8;	{ case nesting limit }
	caseStackSize = 256;	{ limits number of labels in a case }
	{ Case max range limits the difference between the smallest and
	  largest label values (i.e. the size of case branching tables. }
	caseMaxRange = 256;
	valueStackSize = 14;
	countStackSize = 14;
	fixStackSize = 250;
	patchTableSize = 1000;
	maxTokenLength = 80;		{ corresponds to parser maximum }
	sslTableSize = 5000;
	minInteger = -32767;
	maxInteger = 32767;
	minusOne = -1;
	null = 0;
	undefined = minInteger;

	{ Parser generated identifier table indices }
	standardInputNameIndex = pidInput;	
	standardOutputNameIndex = pidOutput; 	

    type
	InputTokens = firstInputToken .. lastInputToken;
	ErrorCodes = firstErrorCode .. lastErrorCode;

	{ S/SL System Failure Code Type }
	FailureCodes = firstFailureCode .. lastFailureCode;

	SymbolKinds = syConstant .. syUndefined;
	TypeKinds = tpInteger .. tpNull;
	SymbolTblReference = 0 .. symbolTblSize;
	SymbolStkReference = 0 .. symbolStkSize;
	TypeTblReference = 0 .. typeTblSize;
	TypeStkReference = 0 .. typeStkSize;
	IdentTblReference = 0 .. identTblSize;
	CaseStackReference = 0 .. caseStackSize;

    var
	{ The Syntax/Semantic Table;
	  The S/SL table file produced by the S/SL Processor 
	  for the pass is read into this array during initialization. }
	sslTable: packed array [0 .. sslTableSize] of 
	    minSslTableValue .. maxSslTableValue;
	semanticSsl: file of integer;

	{ Table Walker State }
	processing: 
	    Boolean  { initially true };
	sslPointer: 
	    0 .. sslTableSize  { initially 0 };
	operation:
	    integer;

	{ Tracing Control }
	options:
	    text;
	tracing:
	    Boolean  { initially false };

	{ Abort flag }
	sslabort:
	    Boolean  { initially false};

	{ The S/SL Rule Call Stack:
	  The Rule Call Stack implements Syntax/Semantic
	  Language rule call and return.
	  Each time an oCall operation is executed,
	  the table return address is pushed onto the
	  Rule Call Stack.  When an oReturn is executed,
	  the return address is popped from the stack.
	  An oReturn executed when the Rule Call Stack is
	  empty terminates table execution.		}
	sslStack:
	    array [1 .. sslStackSize] of 0 .. sslTableSize;
	sslTop:
	    0 .. sslStackSize  { initially 0 };

	{ Choice Match Flag:
	  Set by the Choice Handler to indicate whether
	  a match was made or the otherwise path was taken.
	  Set to true if a match was made and false otherwise.
	  This flag is used in input choices to indicate
	  whether the choice input token should be accepted or
	  not.							}
	choiceTagMatched:
	    Boolean;

	{ Parameterized And Choice Semantic Operation Values:
	  These are used to hold the decoded parameter value to
	  a parameterized semantic operation and the result
	  value returned by a choice semantic operation
	  or rule respectively.					 }
	parameterValue:
	    integer;
	resultValue:
	    integer;

	{ Line Counters }
	nextLineNumber:
	    0 .. maxLineNumber	{ initially 1 };
	lineNumber:
	    0 .. maxLineNumber;
	lastEmittedLineNumber:
	    0 .. maxLineNumber;	{ initially 0 }

	{ Error Counter }
	noErrors:
	    0 .. maxErrors  { initially 0 };

	{ Input Interface }
	parseStream:
	    file of integer;
	nextInputToken:
	    InputTokens;

	{ The Compound Input Token Buffer;
	  When a compound input token is accepted from
	  the input stream, its associated value is
	  saved in the compound token buffer for use by
	  the Semantic Mechanisms of the pass.		}
	compoundToken:
	    InputTokens;	{ Last compound input token accepted }
	compoundTokenValue:
	    integer;		{ Its associated value }
	compoundTokenLength:
	    0 .. maxTokenLength;	{ Its associated length }
	{ (The ord of) its character representation if it
	  is a literal string or an external procedure name }
	compoundTokenText :
	    array [1 .. maxTokenLength] of integer;

	{ Output Interface }
	{ Unpatched code area (t-code) }
	temp :
	    file of integer;
	{ t-code header and patched code area (t-code) }
	tCode:
	    file of integer;

	{ Global Temporaries }
	i: integer;
	j: integer;

	{ Ident Table }
	identSymbolTblRef :  array [1 .. identTblSize] of integer;

	{ Symbol Table }
	symbolTblIdentLink :  array [1 .. symbolTblSize] of integer;
	symbolTblKind :  array [1 .. symbolTblSize] of SymbolKinds;
	symbolTblValue :  array [1 .. symbolTblSize] of integer;
	symbolTblTypeTblLink :  array [1 .. symbolTblSize] of TypeTblReference;
	symbolTblTop :  SymbolTblReference;	{ initially 0 }

	{ Lexic Level Stack }
	symbolTblDisplay :  array [1 .. lexicLevelStackSize] of SymbolTblReference;
	typeTblDisplay :  array [1 .. lexicLevelStackSize] of TypeTblReference;
	lexicLevelStackTop :  0 .. lexicLevelStackSize;   { initially 0 }

	{ Symbol Stack }
	symbolStkIdentTblRef :  array [1 .. symbolStkSize] of integer;
	symbolStkSymbolTblRef :  array [1 .. symbolStkSize] of SymbolTblReference;
	symbolStkKind :  array [1 .. symbolStkSize] of SymbolKinds;
	symbolStkValue :  array [1 .. symbolStkSize] of integer;
	symbolStkTypeTblLink :  array [1 .. symbolStkSize] of TypeTblReference;
	symbolStkTop :  SymbolStkReference;	{ initially 0 }

	{ Type Table }
	typeTblKind :  array [1 .. typeTblSize] of TypeKinds;
	typeTblLowerBound :  array [1 .. typeTblSize] of integer;
	typeTblUpperBound :  array [1 .. typeTblSize] of integer;
	typeTblComponentLink :  array [1 .. typeTblSize] of TypeTblReference;
	typeTblTop :  TypeTblReference;		{ initially 0 }

	{ Type Stack }
	typeStkTypeTblRef :  array [1 .. typeStkSize] of TypeTblReference;
	typeStkKind :  array [1 .. typeStkSize] of TypeKinds;
	typeStkLowerBound :  array [1 .. typeStkSize] of integer;
	typeStkUpperBound :  array [1 .. typeStkSize] of integer;
	typeStkComponentLink :  array [1 .. typeStkSize] of TypeTblReference;
	typeStkTop :  TypeStkReference;		{ initially 0 }

	{ Count Stack }
	countStack :  array [1 .. countStackSize] of integer;
	countStackTop :  0 .. countStackSize;	{ initially 0 }

	{ Fix Address Stack }
	fixStack :  array [1 .. fixStackSize] of integer;
	fixStackTop :  0 .. fixStackSize;	{ initially 0 }

	{ Value Stack }
	valueStack :  array [1 .. valueStackSize] of integer;
	valueStackTop :  0 .. valueStackSize;	{ initially 0 }

	{ Case Stack }
	caseDisplay :  array [1 .. caseDisplaySize] of CaseStackReference;
	caseDisplayTop :  0 .. caseDisplaySize;	{ initially 0 }

	caseLabelStack :  array [1 .. caseStackSize] of integer;
	caseAddressStack :  array [1 .. caseStackSize] of integer;
	caseStackTop :  0 .. caseStackSize;	{ initially 0 }

	{ Data Area Allocation }
	dataAreaEnd :  integer;		{ initially 0 }

	{ Code Area }
	codeAreaEnd :  integer;		{ initially 0 }

	{ Code Area Patch Table }
	patchAddresses :  array [1 .. patchTableSize] of integer;
	patchValues :  array [1 .. patchTableSize] of integer;
	patchTableTop :  0 .. patchTableSize;	{ initially 0 }

	{ Predefined type table entries }
	standardIntegerTypeRef :  TypeTblReference;
	standardStringTypeRef :  TypeTblReference; 	(********** CHANGED *)
	standardBooleanTypeRef :  TypeTblReference;
	standardTextTypeRef :  TypeTblReference;
	
	{ UNIX argument file names }
	{NsemanticSsl, NparseStream, Ntemp, NtCode, Noptions:
		packed array [1 .. 50] of char;}


    procedure Assert (assertion: Boolean; number: integer);
	{ Procedure to implement programmer assertion checking
	  with identification numbers.				}
	begin
	    if not assertion then
		begin
		    write ('### Semantic Assertion ', number: 1, ' failed');
		    writeln;
		    { Cause the compiler to abort at run-time }
		    case 2 of 1: end;
		end;
	end { Assert };


    procedure Initialize;
	{ Enter predefined identifiers into the symbol and type tables,
	  initialize the semantic data structures, open the input and
	  output streams, read the options file.			}
	var
	    c :  char;

	begin
	    { Get UNIX argument file names }
	    {* writeln("foo"); *}
	    {
	    argv (1, NsemanticSsl);
	    argv (2, NparseStream);
	    argv (3, Ntemp);
	    argv (4, NtCode);
	    argv (5, Noptions);
	    }
	    {writeln("bar");}
	   

	    { Trace Execution if Required }
	    tracing := false;
	    reset (options {, Noptions} );

	    if not eof (options) then
		begin
		    read (options, c);

		    if c = 't' then
			begin
			    read (options, c);
			    tracing := (c = '3');
			end;
		end;

	    noErrors := 0;
	    sslabort := false;

	    { Initialize S/SL Input/Output streams }
	    rewrite (temp {, Ntemp} );
	    reset (parseStream {, NparseStream} );
	    nextInputToken := sNewLine;
	    nextLineNumber := 1;
	    lastEmittedLineNumber := 0;

	    { Read in the S/SL Table }
	    reset (semanticSsl {, NsemanticSsl} );
	    i := 0;
	    while not eof(semanticSsl) do
		begin
		    if i > sslTableSize then
			Assert(false, assert22);
		    read(semanticSsl, sslTable[i]);
		    i := i + 1;
		end;

	    { Initialize symbol and type table entries for the
	      predeclared identifiers.  The parser has assigned
	      the predeclared identifiers to the first entries in
	      the semantic pass identifier table.  Use this knowledge
	      to link the identifier and symbol table entries for
	      predeclared identifiers.  The order of the
	      predeclared identifiers in the parser's stdIdentifier
	      file must match the order assumed here.		   }

	    { Initialize the identifier table }
	    i := 1;
	    while i <= identTblSize do
		begin
		    identSymbolTblRef[i] := -i;
		    i := i + 1;
		end;

	    { Link the symbol and identifier table entries }
	    i := firstPredeclaredId;
	    while i <= lastPredeclaredId do
		begin
		    identSymbolTblRef[i] := i;
		    symbolTblIdentLink[i] := -i;
		    i := i + 1;
		end;

	    { Enter standard identifiers in the symbol and type tables.
	      The symbol and type table entries for predefined identifiers
	      have the same table index as the identifier itself. }

	    { integer }
	    symbolTblKind[pidInteger] := syType;
	    symbolTblTypeTblLink[pidInteger] := pidInteger;
	    typeTblKind[pidInteger] := tpInteger;
	    { This index is used by the semantic mechanisms to
	      link to predefined type integer; similarly for
	      char, Boolean and text.				}
	    standardIntegerTypeRef := pidInteger;

(********** CHANGED *)
(*	    { char }					*)
(*	    symbolTblKind[pidChar] := syType;		*)
(*	    symbolTblTypeTblLink[pidChar] := pidChar;	*)
(*	    typeTblKind[pidChar] := tpChar;		*)
(*	    standardCharTypeRef := pidChar;		*)
(**********)
	    { string }
	    symbolTblKind[pidString] := syType;
	    symbolTblTypeTblLink[pidString] := pidString;
	    typeTblKind[pidString] := tpString;
	    standardStringTypeRef := pidString;
(**********)

	    { Boolean }
	    symbolTblKind[pidBoolean] := syType;
	    symbolTblTypeTblLink[pidBoolean] := pidBoolean;
	    typeTblKind[pidBoolean] := tpBoolean;
	    standardBooleanTypeRef := pidBoolean;

	    { text (i.e. file of char) }
	    symbolTblKind[pidText] := syType;
	    symbolTblTypeTblLink[pidText] := pidText;
	    typeTblKind[pidText] := tpFile;
	    typeTblComponentLink[pidText] := standardStringTypeRef; 	(********** CHANGED *)
	    standardTextTypeRef := pidText;

	    { true (1) }
	    symbolTblKind[pidTrue] := syConstant;
	    symbolTblValue[pidTrue] := 1;
	    symbolTblTypeTblLink[pidTrue] := standardBooleanTypeRef;

	    { false (0) }
	    symbolTblKind[pidFalse] := syConstant;
	    symbolTblValue[pidFalse] := 0;
	    symbolTblTypeTblLink[pidFalse] := standardBooleanTypeRef;

	    { Standard routines are distinguished from user routines
	      by negative value fields; a user defined routine has
	      its code address in this field.			      }

	    { reset }
	    symbolTblKind[pidReset] := syProcedure;
	    symbolTblValue[pidReset] := -rtReset;

	    { rewrite }
	    symbolTblKind[pidRewrite] := syProcedure;
	    symbolTblValue[pidRewrite] := -rtRewrite;

	    { write }
	    symbolTblKind[pidWrite] := syProcedure;
	    symbolTblValue[pidWrite] := -rtWrite;

	    { writeln }
	    symbolTblKind[pidWriteln] := syProcedure;
	    symbolTblValue[pidWriteln] := -rtWriteln;

	    { read }
	    symbolTblKind[pidRead] := syProcedure;
	    symbolTblValue[pidRead] := -rtRead;

	    { readln }
	    symbolTblKind[pidReadln] := syProcedure;
	    symbolTblValue[pidReadln] := -rtReadln;

	    { chr }
	    symbolTblKind[pidChr] := syFunction;
	    symbolTblValue[pidChr] := -rtChr;

	    { ord }
	    symbolTblKind[pidOrd] := syFunction;
	    symbolTblValue[pidOrd] := -rtOrd;

	    { eoln }
	    symbolTblKind[pidEoln] := syFunction;
	    symbolTblValue[pidEoln] := -rtEoln;

	    { eof }
	    symbolTblKind[pidEof] := syFunction;
	    symbolTblValue[pidEof] := -rtEof;

	    { assign }
	    symbolTblKind[pidAssign] := syProcedure;
	    symbolTblValue[pidAssign] := -rtAssign;

	    Assert(lastPredeclaredId = pidAssign, assert58);

	    symbolTblTop := lastPredeclaredId;	{ number of predefined symbols entered above }
	    typeTblTop := lastPredeclaredType;	{ number of predefined types entered above }

	    lexicLevelStackTop := 0;
	    symbolStkTop := 0;
	    typeStkTop := 0;
	    countStackTop := 0;
	    valueStackTop := 0;
	    fixStackTop := 0;
	    caseDisplayTop := 0;
	    caseStackTop := 0;
	    patchTableTop := 0;
	    codeAreaEnd := 0;
	    dataAreaEnd := 0;

	end;	{ Initialize }


    procedure Error (errCode: ErrorCodes);
	{ This procedure Emits the error message associated with errCode }
	begin
	    { Semantic errors are in the accepted token }
	    write ('line ', lineNumber: 1, ': ');

	    case errCode of
		eDuplicateName:
		    write('identifier repeated in list');
		eMultiplyDefined:
		    write('identifier declared twice');
		eUndefinedIdentifier:
		    write('identifier not declared');
		eConstantReqd:
		    write('constant required');
		eNullString:
		    write('null literal string not allowed');
		eSubrangeReqd:
		    write('subrange type required');
		eScalarReqd:
		    write('scalar type required');
		eIntegerConstReqd:
		    write('integer constant required');
		eBounds:
		    write('subrange lower bound exceeds upper bound');
		eSimpleTypeReqd:
		    write('subrange or named type required');
		eExternalUndeclared:
		    write('undeclared external file (program parameter)');
		eExternalDeclare:
		    write('program parameter must be a file variable');
		eFileVarReqd:
		    write('file variable required');
		eFileNameReqd:
		    write('file name string required');
		eOperandOperatorTypeMismatch:
		    write('operand and operator types clash');
		eNonScalarValParm:
		    write('value parameter must be a scalar');
		eParameterTypeMismatch:
		    write('formal and actual parameter types clash');
		ePackedComponentByVar:
		    write('packed component not allowed as actual var parameter');
		eInsufficientActuals:
		    write('not enough actual parameters supplied');
		eExtraActuals:
		    write('too many actual parameters supplied');
		eRecursiveCall:
		    write('recursion not allowed');
		eProcedureReqd:
		    write('procedure name required');
		eTypeIdentifierReqd:
		    write('type identifier required');
		eIntegerExpnReqd:
		    write('integer type expression required');
		eBooleanExpnReqd:
		    write('Boolean type expression required');
		eStringExpnReqd: 				(********** CHANGED *)
		    write('string type expression required');	(********** CHANGED *)
		eArrayVarReqd:
		    write('array variable required');
		eVariableReqd:
		    write('variable required');
		eDuplicateLabel:
		    write('duplicate case label value');
		eExpnOperandReqd:
		    write('expression operand required');
		eTypeMismatch:
		    write('type clash');
		eInvalidExpn:
		    write('invalid expression');
		eInputNotVisible:
		    write('standard input not a program parameter or redeclared locally');
		eOutputNotVisible:
		    write('standard output not a program parameter or redeclared locally');
		eFieldWidth:
		    write('invalid field width specification');
		eWriteExpn:
		    write('invalid write expression');
		eStringFileVarReqd: 	(********** CHANGED *)
		    write('text file required');
		eReadVar:
		    write('invalid read variable');
		eSslStackOverflow:
		    write ('Nesting too deep');
		eSymbolTblOvfl:
		    write('too many symbols  (symbol table)');
		eSymbolStkOvfl:
		    write('too many symbols  (symbol stack)');
		eTypeTblOvfl:
		    write('too many types  (type table)');
		eTypeStkOvfl:
		    write('too many types  (type stack)');
		eCountStackOvfl:
		    write('program too complicated  (S count stack)');
		eFixStackOvfl:
		    write('program too complicated  (S fix stack)');
		eValueStackOvfl:
		    write('program too complicated  (S value stack)');
		eCaseDisplayOvfl:
		    write('case nesting too deep  (case display)');
		eCaseRange:
		    write('case range (largest - smallest label) too large');
		eCaseStackOvfl:
		    write('too many labels in case  (case stack)');
		eLexicLevelStackOvfl:
		    write('procedure nesting too deep (lexic level stack)');
		ePatchTableOvfl:
		    write('program too complicated (S patch table)');
		eIdentTableOvfl:
		    write('too many identifiers (identifier table)');
	    end;

	    writeln;
	    noErrors := noErrors + 1;

	    if (errCode >= firstFatalErrorCode) or (noErrors = maxErrors) then
		begin
		    write ('*** Processing aborted');
		    writeln;
		    sslabort := true;
		    processing := false;
		end;

	end  { Error };


    procedure EmitOutputToken (emittedToken: integer);
	{ Emit an output token to the temp (unpatched t-code) stream }
	begin
	    { Line number tokens are emitted only after a change in the
	      line number value and before emission of a non-line number token }
	    if lineNumber <> lastEmittedLineNumber then
		begin
		    write(temp, tLineNumber);
		    write(temp, lineNumber);
		    codeAreaEnd := codeAreaEnd + 2;
		    lastEmittedLineNumber := lineNumber;
		end;

	    write (temp, emittedToken);
	    codeAreaEnd := codeAreaEnd + 1;

	    { Trace Output }
	    if tracing then
		begin
		    write ('Output token emitted ', emittedToken: 1);
		    writeln;
		end;

	end { EmitOutputToken };


    procedure AcceptInputToken;
	{ This procedure provides the interface to the
	  previous pass;  it is reponsible for handling
	  all input including line number indicators and
	  the values and text associated with input tokens.  }
	var
	    acceptedToken :  InputTokens;

	begin
	    { Accept Token }
	    acceptedToken := nextInputToken;

	    { If the token is a compound token,
	      read its associated value	    	}
	    if (acceptedToken = sIdentifier) or
		   (acceptedToken = sInteger) then
		begin
		    compoundToken := acceptedToken;
		    read (parseStream, compoundTokenValue);
		    { Check that identifier values lie within the identifier table }
		    if (acceptedToken = sIdentifier) and
			   (compoundTokenValue > identTblSize) then
			Error(eIdentTableOvfl);
		end
	    else if acceptedToken = sLiteral then
		begin
		    compoundToken := acceptedToken;
		    read(parseStream, compoundTokenLength);
		    i := 1;
		    while i <= compoundTokenLength do
			begin
			    read(parseStream, compoundTokenText[i]);
			    i := i + 1;
			end
		end;

	    { Update Line Number }
	    lineNumber := nextLineNumber;

	    { Read Next Input Token }
	    repeat
		if eof(parseStream) then
		    nextInputToken := sEndOfFile
		else
		    read (parseStream, nextInputToken);

		if nextInputToken = sNewLine then
		    begin
			{ Update the line counter }
			if nextLineNumber < maxLineNumber then
			    nextLineNumber := nextLineNumber + 1
			else
			    nextLineNumber := 0;
		    end;
	    until nextInputToken <> sNewLine;

	    { Trace Input }
	    if tracing then
		begin
		    write ('Input token accepted ', acceptedToken: 1,
			';  Line ', lineNumber: 1, ';  Next input token ',
			nextInputToken: 1);
		    writeln;
		end;

	end { AcceptInputToken };


    { Semantic Mechanism Operation Routines }

    procedure SymbolStkPush(kind :  SymbolKinds);
	{ If the symbol stack is not full push an entry of
	  the parameter kind, otherwise report an error.  }

	begin
	    if symbolStkTop < symbolStkSize then
		begin
		    symbolStkTop := symbolStkTop + 1;
		    symbolStkKind[symbolStkTop] := kind;
		    symbolStkIdentTblRef[symbolStkTop] := null;
		    symbolStkSymbolTblRef[symbolStkTop] := null;
		    symbolStkTypeTblLink[symbolStkTop] := null;
		    symbolStkValue[symbolStkTop] := null;
		end
	    else
		Error(eSymbolStkOvfl);

	end;	{ SymbolStkPush }


    procedure SymbolStkPushIdentifier(symbolRef :  SymbolTblReference);
	{ If the symbol stack is not full, push an entry with
	  the attributes of the symbol table entry specified by
	  the parameter and the last accepted identifier name,
	  otherwise report an error.			      }

	begin
	    if symbolStkTop < symbolStkSize then
		begin
		    symbolStkTop := symbolStkTop + 1;
		    { The last compound token accepted must have been
		      the identifier that we're pushing now.	     }
		    symbolStkIdentTblRef[symbolStkTop] := compoundTokenValue;
		    symbolStkSymbolTblRef[symbolStkTop] := symbolRef;
		    symbolStkKind[symbolStkTop] := symbolTblKind[symbolRef];
		    symbolStkValue[symbolStkTop] := symbolTblValue[symbolRef];
		    symbolStkTypeTblLink[symbolStkTop] :=
			symbolTblTypeTblLink[symbolRef]
		end
	    else
		Error(eSymbolStkOvfl);

	end;	{ SymbolStkPushIdentifier }


    procedure TypeStkPush(kind :  TypeKinds);
	{ If the type stack is not full push an entry of the
	  parameter kind, otherwise report an error.	    }

	begin
	    if typeStkTop < typeStkSize then
		begin
		    typeStkTop := typeStkTop + 1;
		    typeStkKind[typeStkTop] := kind;
		    typeStkTypeTblRef[typeStkTop] := null;
		    typeStkLowerBound[typeStkTop] := null;
		    typeStkUpperBound[typeStkTop] := null;
		    typeStkComponentLink[typeStkTop] := null;
		end
	    else
		Error(eTypeStkOvfl)

	end;	{ TypeStkPush }


    procedure TypeStkPushTypeTbl(typeRef :  TypeTblReference);
	{ If the type stack is not full, push an entry with
	  the attributes of the type table entry specified by
	  the parameter, otherwise report an error.		}

	begin
	    if typeStkTop < typeStkSize then
		begin
		    typeStkTop := typeStkTop + 1;
		    typeStkTypeTblRef[typeStkTop] := typeRef;
		    typeStkKind[typeStkTop] := typeTblKind[typeRef];
		    typeStkLowerBound[typeStkTop] := typeTblLowerBound[typeRef];
		    typeStkUpperBound[typeStkTop] := typeTblUpperBound[typeRef];
		    typeStkComponentLink[typeStkTop] :=
				typeTblComponentLink[typeRef];
		end
	    else
		Error(eTypeStkOvfl);

	end;	{ TypeStkPushTypeTbl }


    procedure TypeStkCopy(src :  TypeStkReference;
			  dst :  TypeStkReference);
	{ Copy the type stack entry specified by the src parameter
	  to the type stack entry specified by the dst parameter.   }

	begin
	    typeStkTypeTblRef[dst] := typeStkTypeTblRef[src];
	    typeStkKind[dst] := typeStkKind[src];
	    typeStkLowerBound[dst] := typeStkLowerBound[src];
	    typeStkUpperBound[dst] := typeStkUpperBound[src];
	    typeStkComponentLink[dst] := typeStkComponentLink[src]
	end;	{ TypeStkCopy }


    procedure ValueStackPush(value :  integer);
	{ If the value stack is not full, push the parameter
	  value, otherwise report an error.		    }

	begin
	    if valueStackTop < valueStackSize then
		begin
		    valueStackTop := valueStackTop + 1;
		    valueStack[valueStackTop] := value
		end
	    else
		Error(eValueStackOvfl)

	end;	{ ValueStackPush }


    procedure EmitCaseBranchTable;
	{ Determine the minimum and maximum label values that occur
	  in the case statement.  If the range of label values is
	  greater than is allowed report an error, otherwise emit
	  the minimum and maximum values followed by the case branch
	  table.						    }
	var
	    min :  integer;
	    max :  integer;
	    base :  CaseStackReference;

	begin
	    min := maxInteger;
	    max := minInteger;
	    i := caseDisplay[caseDisplayTop];
	    j := 0;
	    while i < caseStackTop do
		begin
		    i := i + 1;
		    if caseLabelStack[i] < min then
			min := caseLabelStack[i];
		    if caseLabelStack[i] > max then
			max := caseLabelStack[i];
		end;

	    if max - min > caseMaxRange then
		Error(eCaseRange)
	    else
		begin
		    EmitOutputToken(min);
		    EmitOutputToken(max);
		    base := caseDisplay[caseDisplayTop];
		    { no sort so O(n**2/2) }
		    j := min;
		    repeat
			i := base;
			while i < caseStackTop do
			    begin
				i := i + 1;
				if caseLabelStack[i] = j then
				    begin
					{ Emit the t-code address corresponding
					  to this label value.		     }
					EmitOutputToken(caseAddressStack[i]);
					i := caseStackTop + 1;	{ exit }
				    end
			    end;

			if i <= caseStackTop then
			    { No label matched this value;
			      emit a dummy null address.  }
			    EmitOutputToken(minusOne);

			j := j + 1;
		    until j > max;
		end

	end;	{ EmitCaseBranchTable }


    procedure SslSyntaxError;
	{ A syntax error in the semantic token stream implies
	  a compiler failure.  Either the parser is generating
	  an invalid stream or the semantic analyzer expects
	  an invalid stream.					}
	begin
	    Assert(false, assert3);
	end { SslSyntaxError };


    procedure SslTrace;
	begin
	    write ('Table index ', sslPointer-1: 1, ';  Operation ', 
		operation: 1, ';  Argument ', sslTable[sslPointer]: 1);
	    writeln;
	end  { SslTrace };


    procedure SslFailure (failCode: FailureCodes);
	begin
	    write ('### S/SL program failure:  ');

	    case failCode of
		fSemanticChoiceFailed:
		    write ('Semantic choice failed');
		fChoiceRuleFailed:
		    write ('Choice rule returned without a value');
	    end;

	    writeln;
	    write ('while processing line ', lineNumber);
	    writeln;
	    SslTrace;
	    Assert (false, assert4);
	end { SslFailure };


    procedure SslChoice (choiceTag: integer);
	{ This procedure performs both input and semantic
	  choices.  It sequentially tests each alternative
	  value against the tag value, and when a match is
	  found, performs a branch to the corresponding
	  alternative path.  If none of the alternative
	  values matches the tag value, sslTable interpretation
	  proceeds to the operation immediately following
	  the list of alternatives (normally the otherwise
	  path).  The flag choiceTagMatched is set to true
	  if a match is found and false otherwise.		}

	var numberOfChoices:
	    integer;
	begin
	    sslPointer := sslPointer + sslTable[sslPointer];
	    numberOfChoices := sslTable[sslPointer];
	    sslPointer := sslPointer + 1;
	    choiceTagMatched := false;

	    repeat
		if sslTable[sslPointer] = choiceTag then
		    begin
			sslPointer := sslPointer + 1;
			sslPointer := sslPointer - sslTable[sslPointer];
			choiceTagMatched := true;
			numberOfChoices := 0;
		    end
		else
		    begin
			sslPointer := sslPointer + 2;
			numberOfChoices := numberOfChoices - 1;
		    end;
	    until numberOfChoices = 0;

	    if tracing then
		begin
		    write ('Choice tag ', choiceTag : 1);
		    if choiceTagMatched then
			write (' (matched)')
		    else
			write (' (not matched)');
		    writeln
		end

	end { SslChoice };


    procedure SslWalker;
	{ Walk the semantic analysis S/SL table }
	var
	    symbolRef :  SymbolTblReference;
	    typeRef :  TypeTblReference;
	    link :  integer;
	    byteOffset :  0 .. wordSize;
	    size :  integer;

	begin
	    { Initialize Table Walker State }
	    processing := true;
	    sslPointer := 0;
	    sslTop := 0;
	    AcceptInputToken;

	    repeat
		operation := sslTable[sslPointer];
		sslPointer := sslPointer + 1;

		{ Trace Execution }
		if tracing then
		    SslTrace;

		case operation of
		    oCall:
		        if sslTop < sslStackSize then
			    begin
				sslTop := sslTop + 1;
				sslStack[sslTop] := sslPointer + 1;
				sslPointer := sslTable[sslPointer];
			    end
			else
			    begin
				Error (eSslStackOverflow);
				processing := false;
			    end;

		    oReturn:
			if sslTop = 0 then
			    { Return from main S/SL procedure }
			    processing := false
		        else
			    begin
				sslPointer := sslStack[sslTop];
				sslTop := sslTop - 1;
			    end;

		    oRuleEnd:
		        SslFailure (fChoiceRuleFailed);

		    oJumpForward:
		        sslPointer := sslPointer + sslTable[sslPointer];

		    oJumpBack:
		        sslPointer := sslPointer - sslTable[sslPointer];

		    oInput:
		        begin
			    if sslTable[sslPointer] = nextInputToken then
				AcceptInputToken
			    else
				{ Syntax error in input }
				SslSyntaxError;

			    sslPointer := sslPointer + 1;
			end;

		    oInputAny:
		        if nextInputToken <> sEndOfFile then
			    AcceptInputToken
			else
			    { Premature end of file }
			    SslSyntaxError;

		    oInputChoice:
			begin
			    SslChoice (nextInputToken);
			    if choiceTagMatched then
				AcceptInputToken;
			end;

		    oEmit:
			begin
			    EmitOutputToken (sslTable[sslPointer]);
			    sslPointer := sslPointer + 1;
			end;

		    oError:
			begin
			    Error (sslTable[sslPointer]);
			    sslPointer := sslPointer + 1;
			end;

		    oChoice:
			SslChoice (resultValue);

		    oChoiceEnd:
			SslFailure (fSemanticChoiceFailed);

		    oSetParameter:
			begin
			    parameterValue := sslTable[sslPointer];
			    sslPointer := sslPointer + 1;
			end;

		    oSetResult:
			begin
			    resultValue := sslTable[sslPointer];
			    sslPointer := sslPointer + 1;
			end;


		    { Semantic Analysis Semantic Mechanisms }

		    { ****
		      *  *  Symbol Table Mechanism Operations
		      **** }

		    oSymbolTblEnter:
			{ Create a symbol table entry with the attributes
			  of the top symbol stack entry and link it to the
			  top symbol stack entry.			 }

		        if symbolTblTop < symbolTblSize then
			    begin
				symbolTblTop := symbolTblTop + 1;
				symbolTblKind[symbolTblTop] :=
					symbolStkKind[symbolStkTop];
				symbolTblValue[symbolTblTop] :=
					symbolStkValue[symbolStkTop];
				symbolTblTypeTblLink[symbolTblTop] :=
					symbolStkTypeTblLink[symbolStkTop];
				symbolStkSymbolTblRef[symbolStkTop] :=
					symbolTblTop;

				{ Update identifier table links }
				link := symbolStkIdentTblRef[symbolStkTop];

				if link > 0 then
				    { This is a normal identifier, not a dummy
				      identifier generated by the parser's
				      syntax error recovery procedure.	   }
				    begin
					symbolTblIdentLink[symbolTblTop] :=
						identSymbolTblRef[link];
					identSymbolTblRef[link] := symbolTblTop;
				    end
			    end
			else
			    Error(eSymbolTblOvfl);

		    oSymbolTblUpdate:
			{ Copy the attributes of the top symbol stack entry
			  to the symbol table entry it references.	   }

			begin
			    Assert((symbolStkSymbolTblRef[symbolStkTop] <> null),
					assert5);
			    symbolRef := symbolStkSymbolTblRef[symbolStkTop];
			    symbolTblKind[symbolRef] :=
				symbolStkKind[symbolStkTop];
			    symbolTblValue[symbolRef] :=
				symbolStkValue[symbolStkTop];
			    symbolTblTypeTblLink[symbolRef] :=
				symbolStkTypeTblLink[symbolStkTop];
			end;

		    oSymbolTblPushScope:
			{ Push the lexic level stack with pointers to
			  the symbol and type stack tops.		}

			if lexicLevelStackTop < lexicLevelStackSize then
			    begin
				lexicLevelStackTop := lexicLevelStackTop + 1;
				symbolTblDisplay[lexicLevelStackTop] :=
					symbolTblTop;
				typeTblDisplay[lexicLevelStackTop] :=
					typeTblTop;
			    end
			else
			    Error(eLexicLevelStackOvfl);

		    oSymbolTblPopScope:
			{ Pop the lexic level stack, remove local entries
			  from the type table, remove local entries but
			  leave parameter entries on the symbol stack.  }

			begin
			    Assert((lexicLevelStackTop >= 1), assert31);
			    i := symbolTblTop;
			    symbolTblTop := symbolTblDisplay[lexicLevelStackTop];
			    { Set the identifier table pointer to the identifier
			      entry in the closest enclosing scope if there is 
			      one }
			    while i > symbolTblTop do
				begin
				    link := symbolTblIdentLink[i];

				    if link <> null then
					{ This is not a dummy identifier
					  generated by the parser's syntax
					  error recovery procedure.	  }
					begin
					    while link > 0 do
						link := symbolTblIdentLink[link];
					    identSymbolTblRef[-link] :=
						symbolTblIdentLink[i];
					end;

				    i := i - 1
				end;

			    { Preserve parameter entries for procedures }
			    if lexicLevelStackTop > 1 then
				symbolTblTop := symbolTblTop + typeTblLowerBound
				    [symbolTblTypeTblLink[symbolTblTop]];

			    { No local type definitions need be saved since
			      parameters must be declared with global type 
			      names. }
			    typeTblTop := typeTblDisplay[lexicLevelStackTop];
			    lexicLevelStackTop := lexicLevelStackTop - 1;
			end;

(********** ADDED *)
                    { New JT operations }

                    oSymbolTblStripScope:
                        { Revert local entries in the symbol table to previous entries,
                          except for those that are public procedures }

                        begin
                            Assert((lexicLevelStackTop >= 1), assert31);
                            i := symbolTblTop;
                            j := symbolTblDisplay[lexicLevelStackTop];
                            { Set the identifier table pointer to the identifier
                              entry in the closest enclosing scope if there is
                              one }
                            while i > j do
                                begin
                                    if (symbolTblKind[i] <> syPublicProcedure) and
                                       (symbolTblKind[i] <> syPublicFunction) then
                                    begin
                                        link := symbolTblIdentLink[i];

                                        if link <> null then
                                            { This is not a dummy identifier
                                              generated by the parser's syntax
                                              error recovery procedure.   }
                                            begin
                                                while link > 0 do
                                                    link := symbolTblIdentLink[link];
                                                identSymbolTblRef[-link] :=
                                                    symbolTblIdentLink[i];
                                            end;
                                    end;

                                    i := i - 1
                                end;
                        end;

                    oSymbolTblMergeScope:
                        { Merge top two scopes by popping lexicLevel -
                          could optimize space by deleting private symbols, but why bother? }

                        begin
                            Assert((lexicLevelStackTop >= 1), assert31);
                            lexicLevelStackTop := lexicLevelStackTop - 1;
                        end;
(**********)

		    oSymbolTblLookupExternal:
			{ Return yes if the symbol table contains an
			  undeclared external file name (program parameter),
			  otherwise return no.				   }
			begin
			    resultValue := no;
			    Assert((lexicLevelStackTop >= 1), assert6);
			    { Set i to point to the first symbol 
			      in the global program scope.	}
			    i := symbolTblDisplay[1];
			    while i < symbolTblTop do
				begin
				    i := i + 1;

				    if symbolTblKind[i] = syExternal then
					begin
					    resultValue := yes;
					    i := symbolTblTop	{ exit }
					end
				end
			end;


		    { ****
		      *  *  Symbol Stack Mechanism Operations
		      **** }

		    oSymbolStkPush:
			{ Push the symbol stack, setting the kind field
			  from the parameter.				}
			SymbolStkPush(parameterValue);

		    oSymbolStkPushIdentifier:
			{ If the last accepted identifier has a symbol
			  table entry, push the symbol stack using
			  the attributes of that symbol table entry,
			  otherwise push an undefined symbol.		}
			begin
			    Assert((compoundToken = sIdentifier), assert2);

			    if compoundTokenValue < 0 then
				{ This identifier was generated by the
				  parser's error repair mechanism.   }
				SymbolStkPush(syUndefined)
			    else if identSymbolTblRef[compoundTokenValue] > 0 then
				{ The identifier has a symbol table entry. }
				SymbolStkPushIdentifier(identSymbolTblRef
					[compoundTokenValue])
			    else
				{ The identifier has no symbol table entry }
				begin
				    SymbolStkPush(syUndefined);
				    symbolStkIdentTblRef[symbolStkTop] :=
					compoundTokenValue;
				end;
			end;

		    oSymbolStkPushLocalIdentifier:
			{ Special case of PushIdentifier with the
			  symbol table lookup restricted to the local scope }
			begin
			    Assert((compoundToken = sIdentifier), assert23);

			    if compoundTokenValue < 0 then
				SymbolStkPush(syUndefined)
			    else if identSymbolTblRef[compoundTokenValue] >
				symbolTblDisplay[lexicLevelStackTop] then
				    SymbolStkPushIdentifier(identSymbolTblRef
					[compoundTokenValue])
			    else
				begin
				    SymbolStkPush(syUndefined);
				    symbolStkIdentTblRef[symbolStkTop] :=
					compoundTokenValue;
				end;
			end;

		    oSymbolStkPushStandardVariable:
			{ If the parameter standard variable (input or
			  output) was listed in the program parameter
			  list and is visible in the local scope then
			  push the symbol stack using the standard
			  variable's symbol table attributes, otherwise
			  push an undefined symbol.			}
			if parameterValue = stdInput then
			    begin
				i := identSymbolTblRef [standardInputNameIndex];

				if i > 0 then
				    { Input (possibly user defined) is
				      declared in some scope.		}
				    if symbolTblIdentLink[i] =
					-standardInputNameIndex then
					{ Standard input is visible
					  in the current scope.	   }
					SymbolStkPushIdentifier(i)
				    else
					{ Standard input is obscured by
					  a local declaration.		}
					SymbolStkPush(syUndefined)
				else
				    { Input is not a program parameter }
				    SymbolStkPush(syUndefined)
			    end
			else
			    begin
				Assert((parameterValue = stdOutput), assert30);
				i := identSymbolTblRef[standardOutputNameIndex];
				if i > 0 then
				    if symbolTblIdentLink[i] =
					-standardOutputNameIndex then
					SymbolStkPushIdentifier(i)
				    else
					SymbolStkPush(syUndefined)
				else
				    SymbolStkPush(syUndefined)
			    end;

		    oSymbolStkPushFormalParameter:
			{ The top symbol is a procedure.  Push the
			  procedure's i'th formal parameter where i
			  is the value of the top count stack entry. }
			begin
(********** CHANGED *)
                            Assert((symbolStkKind[symbolStkTop] = syProcedure) or
                                (symbolStkKind[symbolStkTop] = syPublicProcedure) or
			        (symbolStkKind[symbolStkTop] = syFunction) or
			        (symbolStkKind[symbolStkTop] = syPublicFunction),
                                assert24);
(**********)
			    SymbolStkPushIdentifier(symbolStkSymbolTblRef
				[symbolStkTop] + countStack[countStackTop]);
			end;

		    oSymbolStkSetKind:
			symbolStkKind[symbolStkTop] := parameterValue;

		    oSymbolStkLinkToStandardType:
			{ Set the top entry's type table link to point to
			  the parameter-specified standard type table entry. }

			case parameterValue of
			    stdInteger:
				symbolStkTypeTblLink[symbolStkTop] :=
					standardIntegerTypeRef;
(********** CHANGED *)
			    stdString:
				symbolStkTypeTblLink[symbolStkTop] :=
					standardStringTypeRef;
(**********)
			    stdBoolean:
				symbolStkTypeTblLink[symbolStkTop] :=
					standardBooleanTypeRef;
			    stdText:
				symbolStkTypeTblLink[symbolStkTop] :=
					standardTextTypeRef;
			end;

		    oSymbolStkEnterValue:
			{ Set the top entry's value field from the
			  top of the value stack.		  }
			symbolStkValue[symbolStkTop] := valueStack[valueStackTop];

		    oSymbolStkEnterStringValue:
			{ Set the top entry's value field from the first
			  character of the last accepted literal string }
			begin
			    Assert((compoundToken = sLiteral), assert25);
			    symbolStkValue[symbolStkTop] :=
				compoundTokenText[1];
			end;

		    oSymbolStkEnterCodeAddress:
			{ Set the top entry's value field to the offset of
			  the next instruction to be emitted to the code area }
			symbolStkValue[symbolStkTop] := codeAreaEnd;

		    oSymbolStkEnterDataAddress:
			{ Set the top entry's value field to the offset of
			  the next data object to be emitted to the data area }
			symbolStkValue[symbolStkTop] := dataAreaEnd;

		    oSymbolStkEnterTypeReference:
			{ Link the top entry to the top type stack's
			  associated type table entry.		    }
			begin
			    Assert((typeStkTypeTblRef[typeStkTop] <> null),
				assert26);
			    symbolStkTypeTblLink[symbolStkTop] :=
				typeStkTypeTblRef[typeStkTop];
			end;

		    oSymbolStkChooseKind:
			resultValue := symbolStkKind[symbolStkTop];

		    oSymbolStkChooseStandardFile:
			if symbolStkIdentTblRef[symbolStkTop] =
				standardInputNameIndex then
			    resultValue := stdInput
			else if symbolStkIdentTblRef[symbolStkTop] =
				standardOutputNameIndex then
			    resultValue := stdOutput
			else
			    resultValue := stdNull;

		    oSymbolStkChooseStandardRoutine:
			{ Standard routines are distinguished from user
			  defined routines by their negative value fields }
			begin
(********** CHANGED *)
                            Assert((symbolStkKind[symbolStkTop] = syProcedure) or
                                   (symbolStkKind[symbolStkTop] = syPublicProcedure) or
				   (symbolStkKind[symbolStkTop] = syFunction) or
				   (symbolStkKind[symbolStkTop] = syPublicFunction),
				    assert27);
(**********)
			    if symbolStkValue[symbolStkTop] < 0 then
				resultValue := -symbolStkValue[symbolStkTop]
			    else
				resultValue := rtNull;
			end;

		    oSymbolStkPop:
			begin
			    Assert((symbolStkTop > 0), assert7);
			    symbolStkTop := symbolStkTop - 1
			end;


		    { ****
		      *  *  Type Table Mechanism Operations
		      **** }

		    oTypeTblEnter:
			{ Create a type table entry with the attributes
			  of the top type stack entry and link it to the
			  top type stack entry.				}

			if typeTblTop < typeTblSize then
			    begin
				typeTblTop := typeTblTop + 1;
				typeTblKind[typeTblTop] := 
					typeStkKind[typeStkTop];
				typeTblLowerBound[typeTblTop] :=
					typeStkLowerBound[typeStkTop];
				typeTblUpperBound[typeTblTop] :=
					typeStkUpperBound[typeStkTop];
				typeTblComponentLink[typeTblTop] :=
					typeStkComponentLink[typeStkTop];
				typeStkTypeTblRef[typeStkTop] := typeTblTop
			    end
			else
			    Error(eTypeTblOvfl);

		    oTypeTblUpdate:
			{ Copy the top type stack entry attributes
			  to the type table entry it references.   }
			begin
			    Assert((typeStkTypeTblRef[typeStkTop] <> null), assert8);
			    typeRef := typeStkTypeTblRef[typeStkTop];
			    typeTblKind[typeRef] := typeStkKind[typeStkTop];
			    typeTblLowerBound[typeRef] :=
					typeStkLowerBound[typeStkTop];
			    typeTblUpperBound[typeRef] :=
					typeStkUpperBound[typeStkTop];
			    typeTblComponentLink[typeRef] :=
					typeStkComponentLink[typeStkTop];
			end;


		    { ****
		      *  *  Type Stack Mechanism Operations
		      **** }

		    oTypeStkPush:
			{ Push and entry of the parameter kind }
			TypeStkPush(parameterValue);

		    oTypeStkPushSymbol:
			{ If the top symbol stack entry is linked to a type
			  table entry, push a copy of the type entry,
			  otherwise push a null type.			  }
			if symbolStkTypeTblLink[symbolStkTop] <> null then
			    TypeStkPushTypeTbl(symbolStkTypeTblLink[symbolStkTop])
			else
			    TypeStkPush(tpNull);

		    oTypeStkPushComponent:
			{ If the top type stack entry is linked to a component
			  type table entry push a copy of the component type
			  entry, otherwise push a null type.		      }
			if typeStkComponentLink[typeStkTop] <> null then
			    TypeStkPushTypeTbl(typeStkComponentLink[typeStkTop])
			else
			    TypeStkPush(tpNull);

		    oTypeStkSetKind:
			typeStkKind[typeStkTop] := parameterValue;

		    oTypeStkSetRecursionFlag:
			typeStkUpperBound[typeStkTop] := parameterValue;

		    oTypeStkChooseRecursionFlag:
			resultValue := typeStkUpperBound[typeStkTop];

		    oTypeStkSetPackedComponentFlag:
			{ N.B. This implementation implies that a push
			  component operation will never be performed on
			  procedure type; a symbol kind check should be made. }
			typeStkComponentLink[typeStkTop] := parameterValue;

		    oTypeStkChoosePackedComponentFlag:
			resultValue := typeStkComponentLink[typeStkTop];

		    oTypeStkLinkToStandardComponentType:
			{ Set the top entry's component link field to
			  point to a standard type table entry.	     }
			begin
			    { Text is an illegal component type }
			    Assert((parameterValue <> stdText), assert9);

			    case parameterValue of
				stdInteger:
				    typeStkComponentLink[typeStkTop] :=
					standardIntegerTypeRef;
(********** CHANGED *)
				stdString:
				    typeStkComponentLink[typeStkTop] :=
					standardStringTypeRef;
(**********)
				stdBoolean:
				    typeStkComponentLink[typeStkTop] :=
					standardBooleanTypeRef;
			    end
			end;

		    oTypeStkEnterBounds:
			{ Set the upper and lower bound fields from the top
			  and second value stack entries (respectively)   }
			begin
			    Assert((valueStackTop >= 2), assert10);
			    typeStkUpperBound[typeStkTop] :=
				valueStack[valueStackTop];
			    typeStkLowerBound[typeStkTop] :=
				valueStack[valueStackTop-1];
			end;

		    oTypeStkVerifyBounds:
			{ Return yes if the upper bound field is >=
			  the lower bound field, otherwise return no }
			if typeStkUpperBound[typeStkTop] >=
				typeStkLowerBound[typeStkTop] then
			    resultValue := yes
			else
			    resultValue := no;

		    oTypeStkEnterParameterCount:
			{ Set the top entry's parameter count field
			  from the top count.			  }
			begin
(********** CHANGED *)
                            Assert((symbolStkKind[symbolStkTop] = syProcedure) or
                                (symbolStkKind[symbolStkTop] = syPublicProcedure) or
		         	(symbolStkKind[symbolStkTop] = syFunction) or
			        (symbolStkKind[symbolStkTop] = syPublicFunction),
                                assert28);
(**********)
			    typeStkLowerBound[typeStkTop] :=
				countStack[countStackTop];
			end;

		    oTypeStkCompareParameterCount:
			{ Return yes if the parameter count field matches
			  the top count, otherwise return no.		 }
			begin
(********** CHANGED *)
                            Assert((symbolStkKind[symbolStkTop] = syProcedure) or
                                (symbolStkKind[symbolStkTop] = syPublicProcedure) or
		         	(symbolStkKind[symbolStkTop] = syFunction) or
			        (symbolStkKind[symbolStkTop] = syPublicFunction),
                                assert29);
(**********)
			    if typeStkLowerBound[typeStkTop] =
				    countStack[countStackTop] then
				resultValue := yes
			    else
				resultValue := no;
			end;

		    oTypeStkEnterComponentReference:
			{ Set the second entry's component link to
			  point to the top entry's type table entry. }
			begin
			    Assert((typeStkTop >= 2), assert11);
			    Assert((typeStkTypeTblRef[typeStkTop] <> null),assert12);
			    typeStkComponentLink[typeStkTop-1] :=
				typeStkTypeTblRef[typeStkTop];
			end;

		    oTypeStkChooseKind:
			resultValue := typeStkKind[typeStkTop];

		    oTypeStkChooseTypeReference:
			{ Return yes if the top entry has an associated
			  type table entry, otherwise return no.	}
			if typeStkTypeTblRef[typeStkTop] <> null then
			    resultValue := yes
			else
			    resultValue := no;

		    oTypeStkCompareNames:
			{ Return yes if the top 2 entries have the same type
			  table entry (ie were declared with the same type
			  name), otherwise return no.			   }
			begin
			    Assert((typeStkTop >= 2), assert13);
			    Assert((typeStkTypeTblRef[typeStkTop] <> null),
					assert14);
			    Assert((typeStkTypeTblRef[typeStkTop-1] <> null),
					assert15);
			    if typeStkTypeTblRef[typeStkTop] =
					typeStkTypeTblRef[typeStkTop-1] then
				resultValue := yes
			    else
				resultValue := no
			end;

		    oTypeStkSwap:
			{ Switch the positions of the top 2 entries. }
			begin
			    Assert((typeStkTop >= 2), assert16);

			    if typeStkTop < typeStkSize then
				begin
				    TypeStkCopy(typeStkTop, typeStkTop+1);
				    TypeStkCopy(typeStkTop-1, typeStkTop);
				    TypeStkCopy(typeStkTop+1, typeStkTop-1);
				end
			    else
				Error(eTypeStkOvfl)
			end;

		    oTypeStkPop:
			begin
			    Assert((typeStkTop > 0), assert17);
			    typeStkTop := typeStkTop -1
			end;


		    { ****
		      *  *  Count Stack Mechanism Operations
		      **** }

		    oCountPush:
			{ Push the parameter value }
			if countStackTop < countStackSize then
			    begin
				countStackTop := countStackTop + 1;
				countStack[countStackTop] := parameterValue
			    end
			else
			    Error(eCountStackOvfl);

		    oCountPop:
			begin
			    Assert((countStackTop >= 1), assert18);
			    countStackTop := countStackTop - 1
			end;

		    oCountPushValue:
			{ Push the top value stack entry }
			begin
			    Assert((valueStackTop >= 1), assert19);
			    if countStackTop < countStackSize then
				begin
				    countStackTop := countStackTop + 1;
				    countStack[countStackTop] :=
					valueStack[valueStackTop];
				end
			    else
				Error(eCountStackOvfl);
			end;

		    oCountIncrement:
			countStack[countStackTop] := countStack[countStackTop] + 1;

		    oCountDecrement:
			countStack[countStackTop] := countStack[countStackTop] - 1;

		    oCountChoose:
			resultValue := countStack[countStackTop];


		    { ****
		      *  *  Fix Address Stack Mechanism Operations
		      **** }

		    oFixPushTargetAddress:
			{ Push the address of the next instruction to be
			  emitted to the code area.  This address will
			  serve as the target of a later backward branch
			  instruction.					}
			if fixStackTop < fixStackSize then
			    begin
				fixStackTop := fixStackTop + 1;
				fixStack[fixStackTop] := codeAreaEnd
			    end
			else
			    Error(eFixStackOvfl);

		    oFixPushForwardBranch:
			{ Save the address of a forward branch instruction
			  operand which will be patched when its target
			  becomes known.				 }
			begin
			    if patchTableTop < patchTableSize then
				begin
				    patchTableTop := patchTableTop + 1;
				    patchAddresses[patchTableTop] := codeAreaEnd
				end
			    else
				Error(ePatchTableOvfl);

			    if fixStackTop < fixStackSize then
				begin
				    fixStackTop := fixStackTop + 1;
				    { Save a pointer to the patch table
				      slot which corresponds to this fix
				      stack entry, so its target can be 
				      filled in when this fix is popped. }
				    fixStack[fixStackTop] := patchTableTop;
				end
			    else
				Error(eFixStackOvfl)
			end;

		    oFixPopTargetAddress:
			{ Pop the target address of a 
			  backward branch instruction.		}
			begin
			    Assert((fixStackTop >= 1), assert32);
			    EmitOutputToken(fixStack[fixStackTop]);
			    fixStackTop := fixStackTop - 1
			end;

		    oFixPopForwardBranch:
			{ Set the target field of a previously emitted
			  forward branch instruction to the address of
			  the next instruction to be emitted to the code
			  area.  The fix is made indirectly through a
			  patch table since the code area is stored as
			  a sequential access file.			}
			begin
			    Assert((fixStackTop >= 1), assert33);
			    patchValues[fixStack[fixStackTop]] := codeAreaEnd;
			    fixStackTop := fixStackTop -1
			end;

		    oFixPopAndEnterValue:
			{ Set the target field of a previously emitted
			  forward branch instruction to the top value stack
			  entry.  The fix is made indirectly through a
			  patch table since the code area is stored as
			  a sequential access file.			}
			begin
			    Assert((fixStackTop >= 1), assert48);
			    Assert((valueStackTop >= 1), assert1);
			    patchValues[fixStack[fixStackTop]] := 
				valueStack[valueStackTop];
			    fixStackTop := fixStackTop -1
			end;

		    oFixSwap:
			{ Switch the positions of the top 2 entries }
			if fixStackTop < fixStackSize then
			    begin
				Assert((fixStackTop >= 2), assert35);
				fixStack[fixStackTop+1] := fixStack[fixStackTop];
				fixStack[fixStackTop] := fixStack[fixStackTop-1];
				fixStack[fixStackTop-1] := fixStack[fixStackTop+1]
			    end
			else
			    Error(eFixStackOvfl);


		    { ****
		      *  *  Value Stack Mechanism Operations
		      **** }

		    oValuePush:
			ValueStackPush(parameterValue);

		    oValuePushInteger:
			{ Push the value of the last integer token accepted }
			begin
			    Assert((compoundToken = sInteger), assert36);
			    ValueStackPush(compoundTokenValue);
			end;

		    oValuePushStringLength:
			{ Push the length of the last
			  literal string token accepted }
			begin
			    Assert((compoundToken = sLiteral), assert37);
			    ValueStackPush(compoundTokenLength)
			end;

		    oValuePushSymbol:
			ValueStackPush(symbolStkValue[symbolStkTop]);

		    oValuePushCount:
			begin
			    Assert((countStackTop >= 1), assert38);
			    ValueStackPush(countStack[countStackTop]);
			end;

		    oValuePushTypeStkLowerBound:
			ValueStackPush(typeStkLowerBound[typeStkTop]);

		    oValuePushTypeStkUpperBound:
			ValueStackPush(typeStkUpperBound[typeStkTop]);

		    oValueNegate:
			begin
			    Assert((valueStackTop >= 1), assert39);
			    valueStack[valueStackTop] := -valueStack[valueStackTop];
			end;

		    oValueChoose:
			begin
			    Assert((valueStackTop >= 1), assert40);
			    resultValue := valueStack[valueStackTop];
			end;

		    oValuePop:
			begin
			    Assert((valueStackTop >= 1), assert20);
			    valueStackTop := valueStackTop - 1;
			end;


		    { ****
		      *  *  Allocator Mechanism Operations
		      **** }

		    oAllocateAlignOnWord:
			{ Set the data area end pointer so that the
			  next variable is emitted on a word boundary }
			begin
			    byteOffset := dataAreaEnd mod wordSize;

			    if byteOffset <> 0 then
				dataAreaEnd := dataAreaEnd + (
				    wordSize - byteOffset);
			end;

		    oAllocateVariable:
			{ Based on the structure and component entries
			  on top of the type stack (structure on top). }
			case typeStkKind[typeStkTop] of
			    tpInteger, tpSubrange:
				dataAreaEnd := dataAreaEnd + wordSize;
(********** CHANGED *)
(*			    tpChar, tpBoolean:	*)
(*				dataAreaEnd := dataAreaEnd + byteSize;	*)
(**********)
			    tpBoolean:
				dataAreaEnd := dataAreaEnd + byteSize;
			    tpString:
				dataAreaEnd := dataAreaEnd + stringSize;
(**********)
			    tpArray, tpPackedArray:
				begin
				    size := typeStkUpperBound[typeStkTop]
					- typeStkLowerBound[typeStkTop] + 1;
				    if (typeStkKind[typeStkTop-1] = tpInteger) or
					   (typeStkKind[typeStkTop-1] = tpSubrange) then
                                        size := size * wordSize
(********** ADDED *)
                                    else if (typeStkKind[typeStkTop-1] = tpString) then
                                        size := size * stringSize;
(**********)

				    dataAreaEnd := dataAreaEnd + size
				end;
			end;

		    oAllocateVarParameter, oAllocateDescriptor:
			{ A variable parameter is allocated space for an
			  address.  An array descriptor is allocated space
			  for an array index bound value.  A file descriptor
			  is allocated space for the integer value by which
			  the file is referenced within the pseudo code. }
			dataAreaEnd := dataAreaEnd + wordSize;


		    { ****
		      *  *  Case Stack Mechanism Operations
		      **** }

		    oCasePushDisplay:
			{ The case display marks the boundary between
			  the label sets of nested cases.  A case display
			  entry points to the last label processed in the
			  case statement surrounding the case statement
			  currently being processed.			}
			if caseDisplayTop < caseDisplaySize then
			    begin
				caseDisplayTop := caseDisplayTop + 1;
				caseDisplay[caseDisplayTop] := caseStackTop;
			    end
			else
			    Error(eCaseDisplayOvfl);

		    oCasePopDisplay:
			begin
			    Assert((caseDisplayTop >= 1), assert21);
			    { Restore the previous case stack top }
			    caseStackTop := caseDisplay[caseDisplayTop];
			    caseDisplayTop := caseDisplayTop - 1;
			end;

		    oCasePushLabel:
			{ Push a label value from the value stack and
			  set its address to the code area address of
			  the next statement to be emitted.	    }
			if caseStackTop < caseStackSize then
			    begin
				caseStackTop := caseStackTop + 1;		
				Assert((valueStackTop >= 1), assert41);
				caseLabelStack[caseStackTop] :=
					valueStack[valueStackTop];
				caseAddressStack[caseStackTop] := codeAreaEnd;
			    end
			else
			    Error(eCaseStackOvfl);

		    oCaseLookupLabel:
			{ Return yes if the top value is already in the
			  label stack for the current case statement,
			  otherwise return no.				}
			begin
			    resultValue := no;
			    { Locate the first label in this case stmt. }
			    Assert((caseDisplayTop >= 1), assert42);
			    i := caseDisplay[caseDisplayTop];
			    while i < caseStackTop do
				begin
				    i := i + 1;
				    Assert((valueStackTop >= 1), assert43);

				    if caseLabelStack[i] =
					valueStack[valueStackTop] then
					begin
					    resultValue := yes;
					    i := caseStackTop	{ exit }
					end
				end
			end;


		    { ****
		      *  *  Emitter Mechanism Operations
		      **** }

		    oEmitNullAddress:
			{ Special value allows a consistency check
			  to be made when the address is patched.  }
			EmitOutputToken(undefined);

		    oEmitValue:
			begin
			    Assert((valueStackTop >= 1), assert44);
			    EmitOutputToken(valueStack[valueStackTop]);
			end;

		    oEmitDataAddress:
			EmitOutputToken(dataAreaEnd);

		    oEmitTrapKind:
			{ Emit a trap identification value }
			EmitOutputToken(parameterValue);

		    oEmitString:
			{ Emit the text of the last literal string accepted }
			begin
			    Assert((compoundToken = sLiteral), assert45);
			    i := 1;
			    while i <= compoundTokenLength do
				begin
				    EmitOutputToken(compoundTokenText[i]);
				    i := i + 1;
				end
			end;

		    oEmitCaseBranchTable:
			EmitCaseBranchTable;

		end { case operation };

	    until not processing;

	    if not sslabort then
		Assert((eof(parseStream)), assert47);

	end { SslWalker };


    procedure Finalize;
	{ Backpatch the t-code file, adding a header which
	  includes an executable indicator flag, code area
	  size and data area size.			  }
	var
	    codeRef :  integer;
	    nextPatchRef :  integer;
	    codeBuffer :  integer;

	begin
	    reset (temp {, Ntemp} );	{ Unpatched code area }
	    rewrite(tCode {, NtCode} );	{ Final t-code file }

	    { Emit a t-code file header }
	    { If no errors were detected the file is marked executable }
	    write(tCode, noErrors);

	    { Data area size }
	    write(tCode, dataAreaEnd);

	    { Code area size }
	    write(tCode, codeAreaEnd);

	    { Patch and emit the code area }
	    i := 1;
	    codeRef := 0;

	    while i <= patchTableTop do
		begin
		    nextPatchRef := patchAddresses[i];

		    { Copy code up to the address to be patched }
		    while codeRef < nextPatchRef do
			begin
			    read(temp, codeBuffer);
			    write(tCode, codeBuffer);
			    codeRef := codeRef + 1
			end;

		    read(temp, codeBuffer);
		    { Consistency check with EmitNullAddress }
		    Assert((codeBuffer = undefined), assert34);
		    write(tCode, patchValues[i]);
		    codeRef := codeRef + 1;
		    i := i + 1
		end;

	    { Copy code following the final patch }
	    while not eof(temp) do
		begin
		    read(temp, codeBuffer);
		    write(tCode, codeBuffer);
		end;

	    { Verify that the final state of the semantic mechanism data
	      structures is legal if the table walker terminated normally. }
	    if not sslabort then
		{ The Symbol Stack, Type Stack, Symbol and Type Display,
		  Count Stack, Value Stack, Fix Address Stack, Case Stack 
		  and Case Display must be empty.     }
		begin
		    Assert(symbolStkTop = 0, assert49);
		    Assert(typeStkTop = 0, assert50);
		    Assert(lexicLevelStackTop = 0, assert51);
		    Assert(countStackTop = 0, assert52);
		    Assert(valueStackTop = 0, assert53);
		    Assert(fixStackTop = 0, assert54);
		    Assert(caseStackTop = 0, assert55);
		    Assert(caseDisplayTop = 0, assert56);
		end;

	end;	{ Finalize }

    { Main program SemanticAnalysis }
    begin
	{ N.B. We assume that the invoker of the semantic pass (e.g. ptc 
	  command) has insured that the input token stream coming from the 
	  parser is legal (i.e. the parser did not abort translation).  
	  If the stream is illegal it will be empty.		    	}
	Initialize;
	SslWalker;
	Finalize;
    end { SemanticAnalysis }.
